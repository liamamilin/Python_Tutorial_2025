[["index.html", "Python tutorial Chapter 1 Python 必学模块清单 1.1 Python 自带的标准库（必须掌握） 1.2 常用第三方库（几乎必学） 1.3 工具类（项目必备）", " Python tutorial Lin Mi 2025-09-20 Chapter 1 Python 必学模块清单 1.1 Python 自带的标准库（必须掌握） 这些库不用安装，Python 自带，能解决绝大部分基础问题： 模块 作用 场景例子 os / sys / pathlib 操作系统接口、路径、环境变量 文件路径拼接、切换目录、读写环境变量 json / csv / configparser 数据存储格式处理 配置文件、JSON 数据、CSV 表格 datetime / time / calendar 时间与日期处理 日志时间戳、定时任务 logging 日志系统 项目调试、记录运行情况 re 正则表达式 文本提取、数据清洗 argparse 命令行参数解析 写命令行工具 subprocess 执行系统命令 调用外部程序 functools / itertools / collections 高级数据结构与工具 LRU 缓存、生成器、计数器、链表 threading / multiprocessing / concurrent.futures 并发与并行 多线程下载、并行计算 sqlite3 轻量数据库 本地数据存储 👉 这些标准库相当于 Python 的基础设施，学会后你可以不依赖第三方库完成很多小项目。 1.2 常用第三方库（几乎必学） 这些库虽然不是标准库，但在数据科学 / Web / 自动化等方向非常常用： 1.2.1 数据处理与科学计算 numpy → 数组计算、线性代数、矩阵运算 pandas → 表格数据处理（Excel/CSV） matplotlib / seaborn → 数据可视化 1.2.2 网络与Web requests → 发送 HTTP 请求 flask / fastapi → 写 Web 服务 / API django → 全功能 Web 框架 1.2.3 自动化与脚本 beautifulsoup4 / lxml → 网页解析 selenium / playwright → 自动化浏览器操作 openpyxl → Excel 文件处理 1.2.4 AI / 数据科学 scikit-learn → 机器学习算法库 torch / tensorflow → 深度学习 transformers (HuggingFace) → NLP 与大模型 1.3 工具类（项目必备） pytest → 测试框架 virtualenv / conda / poetry → 虚拟环境 &amp; 包管理 black / flake8 / isort → 代码格式化 &amp; 风格检查 "],["C2.html", "Chapter 2 操作系统/数据存储 2.1 Python 标准库：os 模块 2.2 Python 标准库：sys 模块 2.3 Python 标准库：pathlib 模块 2.4 Python 标准库：json 模块 2.5 Python 标准库：csv 模块 2.6 Python 标准库：configparser 模块", " Chapter 2 操作系统/数据存储 2.1 Python 标准库：os 模块 2.1.1 核心 (What) os 模块是 Python 内置的 操作系统接口，提供与文件系统、进程、环境变量等进行交互的功能。 它的地位就像一座“桥梁”：让 Python 程序能在不同操作系统（Windows、Linux、macOS）上调用底层功能，同时保持一定的 跨平台统一性。 2.1.2 组成结构 (Dimension) os 模块可以从以下维度来划分： 路径与文件操作 os.path 子模块：路径拼接、拆分、判断文件是否存在等。 文件创建、删除：os.mkdir()、os.remove()。 目录操作 os.listdir()：列出目录内容。 os.chdir()：切换工作目录。 os.makedirs() / os.rmdir()：递归创建 / 删除目录。 环境变量 os.environ：读取和修改系统环境变量。 进程管理 os.system()：运行系统命令。 os.getpid()：获取当前进程 ID。 os.fork()（仅 Unix）：创建子进程。 跨平台抽象 os.name：当前系统 ('posix' / 'nt')。 os.sep：路径分隔符（Windows 是 \\，Linux 是 /）。 2.1.3 原理 (How it works) os 模块本质上是 Python 标准库对底层系统调用的封装。 在 C 语言层面，Python 解释器通过调用 POSIX API（Unix）或 Win32 API（Windows）实现功能。 os.path 是纯 Python 实现的辅助工具，进一步简化了路径处理。 因为不同操作系统接口不完全一致，os 提供统一 API，Python 程序员只需要调用同样的函数，而不用关心底层系统差异。 2.1.4 应用 (Usage) 常见应用场景： 文件管理脚本：批量重命名、删除文件。 自动化任务：运行系统命令，如调用 ffmpeg 转换视频。 跨平台开发：通过 os.path.join() 确保路径在 Windows / Linux 都能正常运行。 进程控制：获取当前 PID，用于守护进程或调试。 读取环境变量：在部署时读取 API Key，而不是写死在代码中。 2.1.5 举例 (Examples) 2.1.5.1 路径与文件操作 import os # 拼接路径 path = os.path.join(&quot;folder&quot;, &quot;file.txt&quot;) print(path) # Linux: folder/file.txt, Windows: folder\\file.txt # 判断文件是否存在 print(os.path.exists(path)) # 获取绝对路径 print(os.path.abspath(&quot;example.py&quot;)) 2.1.5.2 目录操作 # 创建目录 os.makedirs(&quot;test_dir&quot;, exist_ok=True) # 列出目录内容 print(os.listdir(&quot;.&quot;)) # 删除目录 os.rmdir(&quot;test_dir&quot;) 2.1.5.3 环境变量 # 获取环境变量 print(os.environ.get(&quot;PATH&quot;)) # 设置新的环境变量 os.environ[&quot;MY_VAR&quot;] = &quot;hello&quot; print(os.environ[&quot;MY_VAR&quot;]) 2.1.5.4 运行系统命令 # 执行系统命令（跨平台） os.system(&quot;echo Hello OS&quot;) 2.1.6 辨析 (Misunderstanding) 误解 1：os 模块和 shutil 一样。 区别：os 提供底层接口（创建 / 删除 / 改名），shutil 提供更高层的文件操作（复制 / 移动）。 误解 2：路径拼接用字符串 '/' 就行。 问题：跨平台时可能出错（Windows 不能直接用 /）。 正确：用 os.path.join()。 误解 3：os.system() 返回命令的输出。 实际：它返回的是命令的 退出状态码。 如果想要输出，应该用 subprocess 模块。 误解 4：os.remove() 删除文件后不可恢复。 实际：只是让文件系统释放引用，能否恢复取决于底层文件系统。 2.2 Python 标准库：sys 模块 2.2.1 核心 (What) sys 模块是 Python 程序与 解释器交互的接口，它能获取或控制解释器的运行环境。 它不是操作系统层面的接口（像 os），而是 解释器本身的工具箱。 一句话总结：sys 模块让你窥探和操控 Python 解释器的内部。 2.2.2 组成结构 (Dimension) 常用功能可以分为以下几个维度： 解释器信息 sys.version：Python 版本。 sys.platform：当前平台。 sys.executable：解释器路径。 模块与路径管理 sys.modules：已加载模块字典。 sys.path：模块搜索路径。 输入输出 sys.stdin / sys.stdout / sys.stderr：标准输入输出流。 运行时控制 sys.exit()：退出程序。 sys.setrecursionlimit()：设置递归深度上限。 sys.getrecursionlimit()：获取递归限制。 内存与对象信息 sys.getsizeof(obj)：对象所占字节数。 sys.getrefcount(obj)：引用计数（调试 GC）。 命令行参数 sys.argv：运行 Python 脚本时的参数列表。 2.2.3 原理 (How it works) sys 模块是 Python 内置的 C 模块，在解释器启动时加载。 它直接与 解释器的运行时状态挂钩（版本、路径、内存）。 例如： sys.path 来源于环境变量 PYTHONPATH + 内置路径。 sys.argv 来源于命令行启动参数。 sys.stdin/stdout 是对系统输入输出流的封装。 换句话说：sys 模块是 解释器的控制面板。 2.2.4 应用 (Usage) 获取运行环境信息：判断 Python 版本，写兼容性代码。 命令行参数解析：脚本执行时获取用户输入。 调试内存与递归：查看对象内存大小、调整递归深度。 重定向输入输出：改变 sys.stdout，将输出写入文件。 提前退出程序：用 sys.exit() 优雅地结束脚本。 2.2.5 举例 (Examples) 2.2.5.1 获取解释器信息 import sys print(sys.version) # Python 版本 print(sys.platform) # 平台信息 print(sys.executable) # Python 解释器路径 2.2.5.2 命令行参数 # 假设脚本名为 demo.py，运行： # python demo.py hello world import sys print(sys.argv) # 输出: [&#39;demo.py&#39;, &#39;hello&#39;, &#39;world&#39;] 2.2.5.3 控制程序退出 import sys print(&quot;Start&quot;) sys.exit(0) # 0 表示正常退出 print(&quot;这行不会被执行&quot;) 2.2.5.4 修改递归深度 import sys print(sys.getrecursionlimit()) # 默认 1000 sys.setrecursionlimit(2000) # 修改递归上限 2.2.5.5 重定向输出 import sys with open(&quot;output.txt&quot;, &quot;w&quot;) as f: sys.stdout = f print(&quot;这行将写入文件，而不是控制台&quot;) # 恢复 stdout sys.stdout = sys.__stdout__ print(&quot;恢复输出到控制台&quot;) 2.2.6 辨析 (Misunderstanding) 误解 1：sys 模块和 os 模块作用一样。 区别：os 主要是操作系统接口；sys 主要是解释器接口。 误解 2：sys.exit() 会强制杀死进程。 实际：它抛出 SystemExit 异常，外层代码可以捕获并阻止退出。 误解 3：sys.getsizeof(obj) 就能得到对象占用的全部内存。 实际：它返回对象头部大小，不包括嵌套引用对象。 误解 4：sys.argv[0] 永远是脚本名。 实际：在交互模式下可能是空字符串，在某些环境（如 Jupyter）表现不同。 ✅ 总结： sys 模块是 Python 解释器的控制接口，主要用于获取运行环境信息、管理模块路径、处理输入输出、控制程序运行。 它和 os 模块定位不同： os = 与操作系统交互 sys = 与解释器交互 2.3 Python 标准库：pathlib 模块 2.3.1 核心 (What) pathlib 模块是 Python 3.4 引入的 面向对象路径处理库，用 Path 类替代传统的 os.path 函数式调用。 它的核心价值是：让路径操作更直观、更可读，并且跨平台。 一句话总结：pathlib 让“文件路径”成为一个可以操作的对象，而不是单纯的字符串。 2.3.2 组成结构 (Dimension) pathlib 的主要结构： 核心类 Path：自动根据当前操作系统选择合适的路径类。 PurePath：纯路径类，只处理路径字符串，不涉及实际文件系统。 PosixPath / WindowsPath：具体平台实现。 路径属性与方法 属性：.name、.stem、.suffix、.parent、.parts 方法：.exists()、.is_file()、.is_dir()、.iterdir() 文件操作 .read_text() / .write_text() .read_bytes() / .write_bytes() .open() 路径运算 / 运算符重载，用于拼接路径。 文件系统操作 .mkdir()、.rmdir()、.unlink()（删除文件） 2.3.3 原理 (How it works) pathlib 基于 面向对象封装，将路径抽象为 Path 对象。 传统的 os.path 基本是字符串拼接，容易出错；pathlib 则是对底层 os / os.path 的 高层包装。 Path 实例能自动识别系统： 在 Windows 上 → WindowsPath 在 Linux / macOS 上 → PosixPath 方法调用时，最终还是会委托到底层 os 模块执行实际操作。 2.3.4 应用 (Usage) 路径拼接：跨平台处理目录和文件。 文件检查：判断文件或目录是否存在。 目录遍历：批量操作文件。 文件读写：一行代码完成文本/二进制文件读写。 脚本开发：比 os.path 更简洁、可维护性更高。 2.3.5 举例 (Examples) 2.3.5.1 基础路径操作 from pathlib import Path p = Path(&quot;folder&quot;) / &quot;subfolder&quot; / &quot;file.txt&quot; print(p) # folder/subfolder/file.txt (Linux/macOS) # folder\\subfolder\\file.txt (Windows) print(p.name) # file.txt print(p.stem) # file print(p.suffix) # .txt print(p.parent) # folder/subfolder 2.3.5.2 文件系统操作 p = Path(&quot;example.txt&quot;) # 写文件 p.write_text(&quot;Hello pathlib!&quot;) # 读文件 print(p.read_text()) # 判断文件存在 print(p.exists()) # True print(p.is_file()) # True 2.3.5.3 遍历目录 p = Path(&quot;.&quot;) for file in p.iterdir(): print(file) 2.3.5.4 创建和删除目录 p = Path(&quot;test_dir&quot;) p.mkdir(exist_ok=True) print(p.exists()) # True p.rmdir() 2.3.6 辨析 (Misunderstanding) 误解 1：pathlib 完全替代了 os。 实际：多数情况下能替代 os.path，但某些系统功能（如进程、环境变量）仍需 os。 误解 2：路径拼接只能用字符串 +。 正确：在 pathlib 中推荐用 / 运算符，更简洁安全。 误解 3：Path 方法操作文件一定存在。 实际：某些方法（如 .read_text()）在文件不存在时会抛出异常，需要额外判断。 误解 4：Path 是跨语言通用标准。 实际：它只是 Python 内部封装，不是 POSIX 或 Windows 官方标准。 ✅ 总结： pathlib 是 现代 Python 推荐的路径与文件操作方式，比 os.path 更直观、更可维护。 写新项目时，应优先使用 pathlib，保留 os 仅用于系统级功能。 2.4 Python 标准库：json 模块 2.4.1 核心 (What) json 模块是 Python 内置的 JSON 编解码工具，用于在 Python 对象 和 JSON 格式字符串 之间相互转换。 JSON（JavaScript Object Notation）是一种轻量级数据交换格式，常用于网络通信和配置文件。 一句话总结：json 模块让 Python 能“说” JSON 的语言。 2.4.2 组成结构 (Dimension) 常用功能主要分为两大类： 序列化（Python → JSON） json.dumps(obj)：Python 对象转 JSON 字符串。 json.dump(obj, file)：写入文件。 反序列化（JSON → Python） json.loads(str)：JSON 字符串转 Python 对象。 json.load(file)：从文件读取并解析。 参数与定制化 indent：控制缩进，生成更易读的 JSON。 separators：控制分隔符。 ensure_ascii：是否只输出 ASCII。 default：自定义对象转 JSON 的方式。 2.4.3 原理 (How it works) JSON 是一种 文本格式，和 Python 内存对象不同。 json.dumps() 会遍历 Python 对象，根据类型映射转换成字符串： dict → JSON 对象 {} list/tuple → JSON 数组 [] str → JSON 字符串 int/float/bool/None → JSON 数字/布尔/null json.loads() 会解析字符串，重建 Python 对象。 本质上：json 模块是 解析器 + 格式化器，底层由 C 或 Python 实现。 2.4.4 应用 (Usage) 数据交换：API 接口返回/提交 JSON 数据。 配置文件：保存程序配置，用 JSON 代替 INI/自定义格式。 日志存储：保存结构化日志，方便跨语言读取。 对象持久化：比 pickle 更通用（语言无关）。 2.4.5 举例 (Examples) 2.4.5.1 Python 对象 → JSON import json data = {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;is_student&quot;: False} json_str = json.dumps(data) print(json_str) # {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;is_student&quot;: false} 2.4.5.2 JSON → Python 对象 json_str = &#39;{&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 30, &quot;is_student&quot;: true}&#39; data = json.loads(json_str) print(data) # {&#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 30, &#39;is_student&#39;: True} print(data[&quot;name&quot;]) 2.4.5.3 文件操作 # 写入文件 with open(&quot;data.json&quot;, &quot;w&quot;) as f: json.dump(data, f, indent=4) # 读取文件 with open(&quot;data.json&quot;, &quot;r&quot;) as f: loaded = json.load(f) print(loaded) 2.4.5.4 自定义对象 class Person: def __init__(self, name, age): self.name, self.age = name, age p = Person(&quot;Charlie&quot;, 20) # 需要自定义转换函数 json_str = json.dumps(p, default=lambda obj: obj.__dict__) print(json_str) # {&quot;name&quot;: &quot;Charlie&quot;, &quot;age&quot;: 20} 2.4.6 辨析 (Misunderstanding) 误解 1：JSON 和 Python 字典是一样的。 实际：语法相似，但 JSON 是字符串格式，字典是内存对象。 误解 2：所有 Python 对象都能直接转 JSON。 实际：只有基础类型（dict, list, str, int, float, bool, None）支持，其他需自定义转换。 误解 3：json.dumps() 默认输出就是可读格式。 实际：默认紧凑无缩进，可读性差，需要加 indent=4。 误解 4：JSON 可以存储 Python 特有类型（如集合、日期）。 实际：不支持，需要手动转换（如 set → list，datetime → str）。 ✅ 总结： json 模块是 Python 与外部世界交互的通用语言桥梁。 网络通信 → JSON 传输 配置文件 → JSON 存储 对象序列化 → 需自定义 default 写新项目时，推荐优先用 json，而不是 pickle（后者不跨语言、不安全）。 2.5 Python 标准库：csv 模块 2.5.1 核心 (What) csv 模块是 Python 内置的 CSV 文件读写工具，提供统一的接口来处理 逗号分隔值（Comma-Separated Values） 格式的数据。 它能把 CSV 文件中的文本行解析为 Python 对象，也能把 Python 数据结构写回 CSV 文件。 一句话总结：csv 模块是 Python 与表格数据之间的桥梁。 2.5.2 组成结构 (Dimension) 常用功能主要有： Reader 读取器 csv.reader(file)：逐行读取 CSV，返回列表。 csv.DictReader(file)：把每行解析为字典（列名 → 值）。 Writer 写入器 csv.writer(file)：写入列表。 csv.DictWriter(file)：写入字典（需指定字段名）。 参数控制 delimiter：分隔符（默认,，也可用 \\t 等）。 quotechar：引用字符（默认 \"）。 lineterminator：换行符（默认 \\r\\n）。 newline=\"\"：推荐在打开文件时设置，避免多余空行。 辅助类 csv.Sniffer：自动检测分隔符、是否有表头。 2.5.3 原理 (How it works) CSV 文件本质上是 纯文本文件，以分隔符分割字段。 csv.reader 会逐行读取，自动根据分隔符拆分成 Python 列表。 csv.writer 会将列表拼接为字符串，再写入文件。 DictReader/DictWriter 在此基础上加了列名映射，更便于处理表格数据。 底层依然是文本 I/O，csv 模块主要做了 分隔符与转义字符处理。 2.5.4 应用 (Usage) 数据导入导出：读取/写入表格数据文件。 与 Excel 协作：CSV 是最常见的跨平台表格格式。 日志/报表处理：存储结构化数据（比纯 txt 更直观）。 ETL（Extract-Transform-Load）：作为数据流转的一种中间格式。 2.5.5 举例 (Examples) 2.5.5.1 读取 CSV import csv with open(&quot;data.csv&quot;, newline=&quot;&quot;, encoding=&quot;utf-8&quot;) as f: reader = csv.reader(f) for row in reader: print(row) # 输出: [&#39;name&#39;, &#39;age&#39;] [&#39;Alice&#39;, &#39;25&#39;] ... 2.5.5.2 使用 DictReader with open(&quot;data.csv&quot;, newline=&quot;&quot;, encoding=&quot;utf-8&quot;) as f: reader = csv.DictReader(f) for row in reader: print(row[&quot;name&quot;], row[&quot;age&quot;]) 2.5.5.3 写入 CSV data = [ [&quot;name&quot;, &quot;age&quot;], [&quot;Alice&quot;, 25], [&quot;Bob&quot;, 30] ] with open(&quot;output.csv&quot;, &quot;w&quot;, newline=&quot;&quot;, encoding=&quot;utf-8&quot;) as f: writer = csv.writer(f) writer.writerows(data) 2.5.5.4 使用 DictWriter data = [ {&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25}, {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 30} ] with open(&quot;output.csv&quot;, &quot;w&quot;, newline=&quot;&quot;, encoding=&quot;utf-8&quot;) as f: fieldnames = [&quot;name&quot;, &quot;age&quot;] writer = csv.DictWriter(f, fieldnames=fieldnames) writer.writeheader() writer.writerows(data) 2.5.5.5 自动检测文件格式 with open(&quot;data.csv&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: dialect = csv.Sniffer().sniff(f.read(1024)) print(dialect.delimiter) 2.5.6 辨析 (Misunderstanding) 误解 1：CSV 一定用逗号分隔。 实际：CSV 可以用 \\t（制表符）、; 等，只要指定 delimiter。 误解 2：直接用 open(\"file.csv\") 读写就能正确处理所有情况。 实际：换行符、编码（尤其是 Excel 的 GBK/UTF-8-BOM）可能导致问题，建议显式指定 newline=\"\" 和 encoding。 误解 3：CSV 能替代数据库存储。 实际：CSV 不支持索引、事务，仅适合小规模数据或交换数据。 误解 4：用 pandas 就不需要 csv 模块。 实际：pandas.read_csv() 内部就是基于 csv 模块实现的，只是更高级。 ✅ 总结： csv 模块是 Python 处理 表格数据的基础工具，适合轻量级任务： 快速读写表格 → reader / writer 带列名读写 → DictReader / DictWriter 更复杂分析（统计/清洗） → 建议配合 pandas 使用。 2.6 Python 标准库：configparser 模块 2.6.1 核心 (What) configparser 模块是 Python 内置的 INI 配置文件解析器，用于读写类似 Windows .ini 格式的配置文件。 它的目标是让配置数据以 文本文件 的形式存储，便于人类编辑，程序也能方便地加载使用。 一句话总结：configparser 让 Python 程序能直接读写 INI 风格的配置文件。 2.6.2 组成结构 (Dimension) 配置文件的基本结构由 节 (section)、键 (key)、值 (value) 组成： 配置文件格式 [section1] key1 = value1 key2 = value2 [section2] keyA = valueA 核心类 ConfigParser：读写配置文件的主要类。 RawConfigParser：不做变量插值的解析器。 SafeConfigParser：早期版本的安全解析类（已合并进 ConfigParser）。 常用方法 read(filename)：读取文件。 sections()：获取所有节。 options(section)：获取节下的所有键。 get(section, option)：获取值（字符串）。 getint() / getfloat() / getboolean()：获取并转换类型。 set(section, option, value)：设置值。 write(file)：写入文件。 高级功能 变量插值：支持 ${key} 占位符引用。 默认值：可通过 DEFAULT 节定义全局默认。 2.6.3 原理 (How it works) INI 文件本质是 键值对文本文件，通过 [section] 来分组。 configparser 将配置文件解析成类似字典的结构： 最外层是 {section: {key: value}} 的映射。 访问值时，支持自动类型转换与变量替换。 写回文件时，会自动生成符合 INI 格式的文本。 2.6.4 应用 (Usage) 程序配置：保存应用运行参数（如数据库连接、日志级别）。 用户偏好：存储个性化设置（如 GUI 软件配置）。 跨环境管理：同一代码在不同环境读取不同的配置文件。 快速替代 JSON/YAML：在轻量场景下更直观（适合简单配置）。 2.6.5 举例 (Examples) 2.6.5.1 读取配置文件 假设 config.ini 内容如下： [database] host = localhost port = 3306 user = root password = 1234 [logging] level = DEBUG 读取配置： import configparser config = configparser.ConfigParser() config.read(&quot;config.ini&quot;) print(config.sections()) # [&#39;database&#39;, &#39;logging&#39;] print(config[&quot;database&quot;][&quot;host&quot;]) # localhost print(config.getint(&quot;database&quot;, &quot;port&quot;)) # 3306 2.6.5.2 使用默认值 [DEFAULT] debug = true [app] name = MyApp print(config[&quot;app&quot;][&quot;debug&quot;]) # true （继承 DEFAULT） 2.6.5.3 修改并写入文件 config.set(&quot;database&quot;, &quot;port&quot;, &quot;5432&quot;) with open(&quot;config.ini&quot;, &quot;w&quot;) as f: config.write(f) 2.6.5.4 变量插值 [paths] home = /usr/local bin = ${home}/bin print(config[&quot;paths&quot;][&quot;bin&quot;]) # /usr/local/bin 2.6.6 辨析 (Misunderstanding) 误解 1：INI 文件能存储复杂数据结构。 实际：configparser 只支持字符串和简单类型，复杂结构需手动编码（如 JSON 存储在 value 里）。 误解 2：读取时返回原始类型。 实际：默认返回字符串，需用 getint/getboolean 等方法转换。 误解 3：配置修改后会自动保存。 实际：必须调用 write() 显式写入文件。 误解 4：configparser 只支持 .ini 扩展名。 实际：它只认格式，与扩展名无关。 ✅ 总结： configparser 模块是 Python 的 配置文件解析工具，优势是： 直观易读，适合轻量级配置； 支持默认值和变量插值； 类似字典 API，学习成本低。 但它不适合存储复杂嵌套结构（推荐用 json 或 yaml）。 "],["C3.html", "Chapter 3 时间与日期处理/日志系统/正则 3.1 datetime 模块 3.2 time 模块 3.3 calendar 模块 3.4 logging 模块 3.5 re 模块", " Chapter 3 时间与日期处理/日志系统/正则 3.1 datetime 模块 3.1.1 核心 (What) datetime 模块是 Python 处理 日期与时间 的高级库，比 time 模块更直观、更强大。 它支持日期、时间、时间差的表示与运算，常用于日志、调度、数据处理。 一句话总结：datetime 模块让你能像操作数字一样操作日期和时间。 3.1.2 组成结构 (Dimension) datetime 模块的主要类： 日期与时间类 datetime.date：仅日期（年、月、日）。 datetime.time：仅时间（时、分、秒、微秒）。 datetime.datetime：日期 + 时间（常用）。 时间差类 datetime.timedelta：两个日期/时间的差值。 时区类 datetime.timezone：时区对象。 常用方法 today()、now()、utcnow()：获取当前时间。 strftime()：格式化。 strptime()：字符串解析。 replace()：替换字段生成新对象。 3.1.3 原理 (How it works) datetime 模块是对 时间戳 (timestamp) 的高层封装。 核心思想：用类表示不同粒度的时间对象。 date、time、datetime 分别管理不同维度。 timedelta 允许直接做加减运算，避免手动换算秒数。 时区支持基于 timezone（偏移量），比 time 模块更方便。 3.1.4 应用 (Usage) 获取当前时间：日志、调度。 格式化显示：转换为人类可读字符串。 时间解析：把字符串转为 datetime 对象。 时间运算：日期加减（计算未来/过去日期）。 时区处理：UTC ↔︎ 本地时间转换。 3.1.5 举例 (Examples) 3.1.5.1 获取当前时间 from datetime import datetime, date, time print(date.today()) # 2025-09-20 print(datetime.now()) # 2025-09-20 20:10:00.123456 3.1.5.2 格式化与解析 from datetime import datetime now = datetime.now() print(now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)) # 2025-09-20 20:10:00 time_str = &quot;2025-09-20 20:30:00&quot; parsed = datetime.strptime(time_str, &quot;%Y-%m-%d %H:%M:%S&quot;) print(parsed.year, parsed.month, parsed.day) # 2025 9 20 3.1.5.3 时间运算 from datetime import datetime, timedelta today = datetime.now() tomorrow = today + timedelta(days=1) print(tomorrow) # 比今天晚一天 3.1.5.4 时区处理 from datetime import datetime, timezone, timedelta utc_time = datetime.now(timezone.utc) print(&quot;UTC:&quot;, utc_time) beijing_tz = timezone(timedelta(hours=8)) bj_time = utc_time.astimezone(beijing_tz) print(&quot;Beijing:&quot;, bj_time) 3.1.6 辨析 (Misunderstanding) 误解 1：datetime.now() 一定返回本地时间。 实际：是的，但它不带时区信息（naive datetime），要显式加 timezone。 误解 2：strftime 和 strptime 格式可以随意写。 实际：必须严格遵守格式化符号（如 %Y-%m-%d），否则解析失败。 误解 3：timedelta 只支持天数。 实际：支持 days, seconds, microseconds, weeks，可精确到微秒。 误解 4：utcnow() 和 now(timezone.utc) 等价。 实际：utcnow() 返回 naive UTC 时间，没有时区信息； now(timezone.utc) 返回 aware datetime（带时区）。 ✅ 总结： datetime 模块是 Python 日期与时间处理的核心工具： date / time / datetime → 表示不同粒度时间； timedelta → 支持时间运算； timezone → 支持时区转换。 比 time 模块更强大，更适合现代项目。 3.2 time 模块 3.2.1 核心 (What) time 模块提供与 时间相关的函数，包括获取当前时间、格式化显示、休眠、时间戳转换等。 它是 Python 操作 时间戳（timestamp） 和 本地时间（struct_time） 的主要接口。 一句话总结：time 模块让你能在秒级精度上操控“时间”。 3.2.2 2️⃣ 组成结构 (Dimension) 常用功能可以分为几个维度： 时间表示 时间戳（timestamp）：自 1970-01-01 以来的秒数。 结构化时间（struct_time）：一种可读的时间元组。 时间获取 time.time()：当前时间戳。 time.localtime()：本地时间。 time.gmtime()：UTC 时间。 时间格式化与解析 time.strftime()：格式化为字符串。 time.strptime()：从字符串解析为 struct_time。 time.asctime() / time.ctime()：快速字符串化。 程序控制 time.sleep()：让程序暂停指定秒数。 time.perf_counter() / time.process_time()：高精度计时。 时区信息 time.timezone：本地时区与 UTC 的差值（秒）。 time.tzname：本地时区名称。 3.2.3 原理 (How it works) time 模块底层调用 操作系统的 C 标准库时间函数。 时间戳：以秒为单位存储，浮点数表示小数秒。 struct_time：9 元组 (年, 月, 日, 时, 分, 秒, 周几, 一年中的第几天, 夏令时标志)。 sleep()：让解释器挂起当前线程，由操作系统调度恢复。 高精度计时函数（如 perf_counter）基于系统的高精度计时器。 3.2.4 应用 (Usage) 获取当前时间：显示时间戳或格式化为字符串。 定时任务：结合 sleep() 实现简单的轮询。 性能测试：计算代码运行耗时。 日志记录：将事件记录到本地时间或 UTC 时间。 时间解析：从字符串读取时间用于比较或计算。 3.2.5 举例 (Examples) 3.2.5.1 获取当前时间 import time print(time.time()) # 1695225600.12345 (时间戳) print(time.localtime()) # struct_time 本地时间 print(time.gmtime()) # struct_time UTC 时间 3.2.5.2 时间格式化 now = time.localtime() print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, now)) # 2025-09-20 19:30:00 3.2.5.3 时间解析 time_str = &quot;2025-09-20 19:30:00&quot; parsed = time.strptime(time_str, &quot;%Y-%m-%d %H:%M:%S&quot;) print(parsed.tm_year, parsed.tm_mon, parsed.tm_mday) # 2025 9 20 3.2.5.4 程序休眠 print(&quot;Start&quot;) time.sleep(2) # 暂停 2 秒 print(&quot;End&quot;) 3.2.5.5 性能测试 start = time.perf_counter() sum([i for i in range(1000000)]) end = time.perf_counter() print(&quot;耗时:&quot;, end - start, &quot;秒&quot;) 3.2.6 辨析 (Misunderstanding) 误解 1：time.time() 返回本地时间。 实际：它返回 UTC 时间戳（秒），需要用 localtime() 转换。 误解 2：sleep() 精确到毫秒。 实际：受操作系统调度影响，不保证严格精确。 误解 3：strftime() 和 strptime() 能处理所有格式。 实际：必须严格符合格式化字符串，否则报错。 误解 4：ctime() 和 asctime() 永远一致。 实际：ctime() 只接受时间戳，而 asctime() 接受 struct_time。 总结： time 模块是 Python 操作时间的 基础工具，主要面向 秒级精度 与 结构化时间。 获取时间 → time() 格式化时间 → strftime() 延迟执行 → sleep() 高精度计时 → perf_counter() 写更复杂的时间处理（如时区、日期运算），建议用 datetime 模块。 3.3 calendar 模块 3.3.1 核心 (What) calendar 模块是 Python 内置的 日历与日期计算工具，主要用于生成日历、判断闰年、获取星期几等。 它更关注 日历逻辑（如月历表、闰年规则），而不是时间戳。 一句话总结：calendar 模块让你能直接操作和打印“日历”。 3.3.2 组成结构 (Dimension) 主要功能可以分为以下几个维度： 日历生成 calendar.month(year, month)：生成单月日历字符串。 calendar.calendar(year)：生成整年日历字符串。 日期计算 calendar.isleap(year)：判断是否闰年。 calendar.leapdays(y1, y2)：统计某区间的闰年数量。 星期信息 calendar.weekday(year, month, day)：返回星期几（0=周一）。 calendar.monthrange(year, month)：返回该月第一天是星期几 + 当月天数。 迭代器式日历 calendar.Calendar()：生成器形式，按天迭代。 itermonthdays(year, month)：返回该月的日期列表（补齐为整周）。 高级类 TextCalendar：文本形式日历。 HTMLCalendar：HTML 格式日历（适合网页应用）。 3.3.3 原理 (How it works) calendar 模块基于 格里高利历 (Gregorian calendar)，与现实通用历法一致。 内部实现主要依赖数学计算： 判断闰年 → 规则 (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)。 星期计算 → 通过 蔡勒公式 或等价算法实现。 生成的日历实际上是 字符串 或 迭代器，并不涉及系统时间 API。 3.3.4 应用 (Usage) 打印日历：快速显示某年某月的日历。 日期逻辑：判断星期几、计算闰年。 计划任务：结合调度系统，计算某天是星期几。 网页/应用日历：用 HTMLCalendar 生成 HTML 日历。 3.3.5 举例 (Examples) 3.3.5.1 打印日历 import calendar print(calendar.month(2025, 9)) 输出： September 2025 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ... 3.3.5.2 判断闰年 print(calendar.isleap(2024)) # True print(calendar.isleap(2025)) # False 3.3.5.3 获取星期几 print(calendar.weekday(2025, 9, 20)) # 5 （星期六） 3.3.5.4 月份信息 first_weekday, days_in_month = calendar.monthrange(2025, 9) print(first_weekday, days_in_month) # 0 30 （9月1日是周一，9月有30天） 3.3.5.5 迭代日历 cal = calendar.Calendar(firstweekday=6) # 周日为第一天 for day in cal.itermonthdays(2025, 9): print(day, end=&quot; &quot;) # 0 表示填充的空白日 3.3.5.6 生成 HTML 日历 html_cal = calendar.HTMLCalendar().formatmonth(2025, 9) print(html_cal) # &lt;table&gt;...&lt;/table&gt; 3.3.6 辨析 (Misunderstanding) 误解 1：calendar 返回的时间和 datetime 一样。 实际：calendar 专注日历结构，不返回 datetime 对象。 误解 2：isleap 只看能否被 4 整除。 实际：需要完整的闰年规则（世纪年需被 400 整除）。 误解 3：weekday() 返回值和 datetime.weekday() 一样。 实际：两者一致（0=周一），但 calendar 也提供 firstweekday 设置。 误解 4：HTMLCalendar 输出可直接做日程管理。 实际：它只生成静态 HTML，需要额外逻辑才能支持交互。 总结： calendar 模块是 Python 日历逻辑与生成工具，适合： 学习/打印日历； 判断闰年与星期几； 生成 HTML 日历用于网页。 它与 time / datetime 互补： time → 底层秒级时间 datetime → 高级日期时间对象 calendar → 日历与星期逻辑 3.4 logging 模块 3.4.1 核心 (What) logging 模块是 Python 的 日志系统工具，用于跟踪和记录程序运行过程中的信息。 它支持多级别日志（DEBUG/INFO/WARNING/ERROR/CRITICAL），并能将日志输出到控制台、文件或远程服务器。 一句话总结：logging 模块是 Python 程序的“黑匣子”。 3.4.2 组成结构 (Dimension) logging 由四个核心组件组成： Logger（记录器） 程序员直接调用的接口，例如 logging.getLogger(\"app\")。 提供 logger.debug() / info() / warning() / error() / critical()。 Handler（处理器） 决定日志输出到哪里。 常见类型： StreamHandler（控制台） FileHandler（文件） RotatingFileHandler（轮转文件） SMTPHandler（邮件发送） Formatter（格式化器） 定义日志消息的输出格式，例如时间戳、级别、模块名。 Filter（过滤器） 提供更细粒度的日志筛选规则。 3.4.3 原理 (How it works) logging 模块基于 日志事件流： 程序调用 logger 记录日志。 logger 将日志事件传递给一个或多个 handler。 handler 使用 formatter 格式化消息。 日志最终被输出到目标位置（终端、文件、网络）。 日志级别按严重性排序： DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL 日志传播：子 logger 默认会把日志传递到上级 logger（除非关闭）。 3.4.4 应用 (Usage) 调试与开发：用 DEBUG 级别追踪细节。 生产环境监控：记录 WARNING / ERROR 级别到日志文件。 日志持久化：长期保存日志，便于分析历史记录。 安全与合规：日志可作为审计和问题追踪依据。 3.4.5 举例 (Examples) 3.4.5.1 快速入门 import logging logging.basicConfig(level=logging.INFO) logging.info(&quot;程序启动&quot;) logging.warning(&quot;这是一个警告&quot;) logging.error(&quot;出错啦！&quot;) 3.4.5.2 自定义日志格式 logging.basicConfig( level=logging.DEBUG, format=&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot; ) logging.debug(&quot;调试信息&quot;) 3.4.5.3 文件日志 logging.basicConfig( filename=&quot;app.log&quot;, filemode=&quot;a&quot;, level=logging.INFO, format=&quot;%(asctime)s - %(levelname)s - %(message)s&quot; ) logging.info(&quot;日志写入文件&quot;) 3.4.5.4 使用 Logger + Handler + Formatter logger = logging.getLogger(&quot;my_app&quot;) logger.setLevel(logging.DEBUG) # 控制台输出 console_handler = logging.StreamHandler() console_handler.setLevel(logging.INFO) # 文件输出 file_handler = logging.FileHandler(&quot;my_app.log&quot;) file_handler.setLevel(logging.WARNING) # 格式化 formatter = logging.Formatter(&quot;%(asctime)s - %(levelname)s - %(message)s&quot;) console_handler.setFormatter(formatter) file_handler.setFormatter(formatter) # 添加到 logger logger.addHandler(console_handler) logger.addHandler(file_handler) logger.info(&quot;信息日志&quot;) logger.warning(&quot;警告日志&quot;) 3.4.6 辨析 (Misunderstanding) 误解 1：print() 就能代替 logging。 实际：print 没有日志级别、没有持久化，不适合复杂项目。 误解 2：日志级别越低越好。 实际：DEBUG 级别会输出大量信息，生产环境一般用 INFO 或 WARNING。 误解 3：basicConfig 可以随时多次调用。 实际：只能在第一次生效，之后需要手动配置 logger/handler。 误解 4：所有日志都会打印出来。 实际：必须满足 logger 的级别 和 handler 的级别，日志才会输出。 总结： logging 模块是 Python 的 标准日志工具： logger → 产生日志 handler → 发送日志 formatter → 格式化日志 filter → 过滤日志 相比 print，它提供 分级、格式化、持久化、灵活路由，是生产环境必用工具。 3.5 re 模块 3.5.1 核心 (What) re 模块是 Python 的 正则表达式工具，用于对字符串进行匹配、搜索、替换、分割等操作。 正则表达式是一种 模式语言，用来描述字符串的规则。 一句话总结：re 模块让你能用规则批量处理和操作字符串。 3.5.2 组成结构 (Dimension) 常用功能可以分为以下维度： 匹配与搜索 re.match()：从字符串开头匹配。 re.search()：搜索整个字符串，返回第一个匹配。 re.findall()：返回所有匹配的结果列表。 re.finditer()：返回迭代器，逐个匹配结果。 替换与分割 re.sub()：替换字符串中的匹配部分。 re.split()：按模式分割字符串。 编译与复用 re.compile(pattern)：编译正则表达式，提高多次使用的效率。 匹配对象 (MatchObject) .group()：获取匹配内容。 .groups()：获取所有子组内容。 .span()：获取匹配位置。 常用模式语法 字符匹配：.、\\d、\\w、\\s 量词：*、+、?、{m,n} 边界：^、$、\\b 分组：( )、(?: )、(?P&lt;name&gt; ) 3.5.3 原理 (How it works) re 模块基于 有限状态机 (FSM) 和 回溯匹配算法 实现。 匹配流程： 解析正则表达式 → 构建匹配规则。 从输入字符串扫描，尝试匹配模式。 返回第一个匹配（或所有匹配）。 匹配效率与模式设计有关：过多的回溯可能导致性能问题。 3.5.4 应用 (Usage) 文本搜索：检查字符串是否符合格式（如邮箱、手机号）。 文本替换：清理日志、替换敏感词。 文本提取：从 HTML/日志中提取关键信息。 格式校验：验证输入数据格式。 数据清洗：批量处理文件、去掉多余空格等。 3.5.5 举例 (Examples) 3.5.5.1 匹配字符串 import re text = &quot;My phone number is 123-456-7890&quot; m = re.search(r&quot;\\d{3}-\\d{3}-\\d{4}&quot;, text) print(m.group()) # 123-456-7890 3.5.5.2 提取所有匹配 emails = &quot;alice@example.com, bob@test.org&quot; results = re.findall(r&quot;[\\w.-]+@[\\w.-]+&quot;, emails) print(results) # [&#39;alice@example.com&#39;, &#39;bob@test.org&#39;] 3.5.5.3 替换 text = &quot;I have 100 dollars&quot; new_text = re.sub(r&quot;\\d+&quot;, &quot;X&quot;, text) print(new_text) # I have X dollars 3.5.5.4 分割 line = &quot;apple, orange; banana|grape&quot; parts = re.split(r&quot;[,;|]\\s*&quot;, line) print(parts) # [&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;, &#39;grape&#39;] 3.5.5.5 使用编译对象 pattern = re.compile(r&quot;\\b\\w{4}\\b&quot;) print(pattern.findall(&quot;This line has some four word items&quot;)) # [&#39;This&#39;, &#39;line&#39;, &#39;some&#39;, &#39;four&#39;, &#39;word&#39;] 3.5.5.6 分组提取 m = re.match(r&quot;(\\d+)-(\\d+)-(\\d+)&quot;, &quot;2025-09-20&quot;) print(m.groups()) # (&#39;2025&#39;, &#39;09&#39;, &#39;20&#39;) 3.5.6 辨析 (Misunderstanding) 误解 1：re.match() 和 re.search() 一样。 实际：match 只检查开头，search 会扫描整个字符串。 误解 2：. 能匹配所有字符。 实际：默认不能匹配换行符，需加 re.S 或 re.DOTALL。 误解 3：正则表达式越复杂越好。 实际：复杂正则可读性差，易出错，推荐逐步构建。 误解 4：性能和字符串长度线性相关。 实际：错误设计的模式可能引发“灾难性回溯”，导致极慢匹配。 总结： re 模块是 Python 的 文本模式匹配工具： 查找 → search/findall 替换 → sub 分割 → split 提取分组 → match/search + groups 适合用在日志分析、数据清洗、输入校验中，但要避免过度复杂的正则。 "],["C4.html", "Chapter 4 命令行参数解析/执行系统命令 4.1 argparse 模块 4.2 subprocess 模块", " Chapter 4 命令行参数解析/执行系统命令 4.1 argparse 模块 4.1.1 核心 (What) argparse 模块是 Python 内置的 命令行参数解析工具，用于编写可通过命令行运行并带参数的程序。 它能自动生成 帮助文档 和 错误提示，让命令行工具更易用。 一句话总结：argparse 模块让 Python 脚本变成“命令行程序”。 4.1.2 组成结构 (Dimension) 主要组件和功能： ArgumentParser 对象 入口类，负责解析命令行参数。 参数定义方法 add_argument()：定义参数类型、名称、选项。 参数类型： 位置参数（必填） 可选参数（带 - 或 -- 前缀） 常用配置 type：参数类型（int, float, str）。 default：默认值。 help：参数说明。 choices：限制可选值。 action：指定行为（如 store_true）。 解析与结果 parse_args()：返回包含参数的命名空间对象。 自动帮助 自动生成 -h/--help 帮助说明。 4.1.3 原理 (How it works) argparse 读取命令行输入（来自 sys.argv）。 ArgumentParser 将输入与预定义的参数规则对比。 如果匹配成功 → 返回一个 Namespace 对象（类似对象/字典）。 如果不符合规则 → 自动打印错误信息和帮助提示。 4.1.4 应用 (Usage) 命令行工具开发：构建脚本的交互界面。 批处理任务：让脚本支持不同参数运行。 调试与实验：灵活切换输入参数。 生产环境脚本：带 --help，让用户快速上手。 4.1.5 举例 (Examples) 4.1.5.1 基本用法 import argparse parser = argparse.ArgumentParser(description=&quot;示例程序&quot;) parser.add_argument(&quot;filename&quot;, help=&quot;输入文件名&quot;) parser.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;, help=&quot;输出详细信息&quot;) args = parser.parse_args() print(&quot;文件:&quot;, args.filename) if args.verbose: print(&quot;启用详细模式&quot;) 运行： python script.py data.txt --verbose 输出： 文件: data.txt 启用详细模式 4.1.5.2 类型与默认值 parser.add_argument(&quot;--count&quot;, type=int, default=1, help=&quot;循环次数&quot;) 4.1.5.3 限制可选值 parser.add_argument(&quot;--mode&quot;, choices=[&quot;fast&quot;, &quot;slow&quot;], help=&quot;运行模式&quot;) 4.1.5.4 多值参数 parser.add_argument(&quot;--nums&quot;, nargs=&quot;+&quot;, type=int, help=&quot;输入多个数字&quot;) # python script.py --nums 1 2 3 4.1.6 辨析 (Misunderstanding) 误解 1：所有参数都必须是可选的。 实际：位置参数是必填的，可选参数才有 -/-- 前缀。 误解 2：需要手动写帮助信息。 实际：argparse 自动生成 -h/--help，只需写 help 描述。 误解 3：parse_args() 返回字典。 实际：返回 Namespace 对象，可通过 args.attr 访问。 误解 4：报错信息需要手动处理。 实际：argparse 遇到错误时会自动打印错误并退出。 ✅ 总结： argparse 模块是 Python 的 命令行解析工具： 定义参数 → add_argument() 解析参数 → parse_args() 自动帮助 → -h/--help 它比 sys.argv 更安全、更易维护，适合开发可复用的命令行工具。 4.2 subprocess 模块 4.2.1 核心 (What) subprocess 模块是 Python 内置的 子进程管理工具，用于在程序中启动外部进程、执行系统命令，并与其交互（输入、输出、错误流）。 它是 os.system 和 os.spawn* 等旧接口的现代替代方案。 一句话总结：subprocess 模块让 Python 能像“外壳脚本”一样调用其他程序，但更安全、更灵活。 4.2.2 组成结构 (Dimension) 常用接口和功能： 简单执行 subprocess.run()：运行命令，等待完成。 subprocess.call()：类似 run，返回退出码。 subprocess.check_output()：运行命令并返回输出。 进程控制 Popen 类：更底层的接口，支持实时交互。 属性：.pid、.returncode。 方法：.communicate()、.terminate()、.kill()。 输入输出管理 stdout：捕获标准输出。 stderr：捕获错误输出。 stdin：向进程传递输入。 参数选项 shell=True：通过 shell 执行命令（可能有安全风险）。 cwd：指定工作目录。 env：指定环境变量。 timeout：设置超时。 4.2.3 原理 (How it works) subprocess 底层通过 fork/exec（Unix） 或 CreateProcess（Windows） 启动新进程。 父进程（Python）可以与子进程通过 管道 (pipe) 通信。 进程执行完成后，返回退出码，0 表示成功，非 0 表示错误。 run() 封装了 Popen，简化了常见用法。 4.2.4 应用 (Usage) 系统命令执行：运行 shell 脚本、批处理命令。 自动化任务：调用外部工具（如 ffmpeg, git, curl）。 进程控制：启动后台服务、监控进程。 数据管道：捕获外部命令输出并进一步处理。 跨平台脚本：比 os.system 更安全、可控。 4.2.5 举例 (Examples) 4.2.5.1 最简单的命令 import subprocess subprocess.run([&quot;echo&quot;, &quot;Hello Subprocess&quot;]) 4.2.5.2 捕获输出 result = subprocess.run([&quot;ls&quot;, &quot;-l&quot;], capture_output=True, text=True) print(result.stdout) 4.2.5.3 获取命令输出 output = subprocess.check_output([&quot;echo&quot;, &quot;Python&quot;], text=True) print(output.strip()) # Python 4.2.5.4 使用 Popen proc = subprocess.Popen([&quot;grep&quot;, &quot;python&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True) out, err = proc.communicate(&quot;python is great\\njava is ok&quot;) print(out) # python is great 4.2.5.5 设置工作目录和环境变量 subprocess.run([&quot;ls&quot;], cwd=&quot;/tmp&quot;) subprocess.run([&quot;printenv&quot;], env={&quot;MY_VAR&quot;: &quot;123&quot;}) 4.2.5.6 超时控制 try: subprocess.run([&quot;sleep&quot;, &quot;5&quot;], timeout=2) except subprocess.TimeoutExpired: print(&quot;命令超时&quot;) 4.2.6 辨析 (Misunderstanding) 误解 1：os.system 和 subprocess.run 没区别。 实际：os.system 只返回退出码，无法获取输出；subprocess 更灵活安全。 误解 2：shell=True 总是必要的。 实际：多数情况下推荐传列表形式 [\"cmd\", \"arg1\"]，shell=True 可能带来命令注入风险。 误解 3：check_output 总是安全的。 实际：命令出错（非 0 退出）会抛出 CalledProcessError，需要捕获异常。 误解 4：Popen 和 run 作用相同。 实际：run 是对 Popen 的封装，适合简单调用；Popen 更灵活，支持流式交互。 总结： subprocess 模块是 Python 调用外部程序的标准方式： 简单调用 → run / check_output 高级控制 → Popen 捕获 I/O、设置环境变量、超时等功能非常实用。 它比 os.system 更强大、更安全，是现代 Python 项目推荐使用的进程调用工具。 "],["C5.html", "Chapter 5 高级数据结构与工具 5.1 functools 模块 5.2 itertools 模块 5.3 collections 模块", " Chapter 5 高级数据结构与工具 5.1 functools 模块 5.1.1 核心 (What) functools 模块是 Python 内置的 函数式编程工具集，提供了一组高阶函数和装饰器，用于操作或增强函数行为。 它的核心价值在于：让函数更灵活、更可复用。 一句话总结：functools 是 Python 函数的“工具箱”，提供缓存、偏函数、排序键、装饰器等功能。 5.1.2 组成结构 (Dimension) 常用功能大致分为以下几个维度： 函数适配与增强 partial(func, *args, **kwargs)：生成偏函数，固定部分参数。 update_wrapper(wrapper, wrapped) / wraps(wrapped)：保留原函数元数据。 缓存与性能优化 lru_cache(maxsize=None)：基于最近最少使用 (LRU) 的缓存装饰器。 cache（Python 3.9+）：无限缓存装饰器。 比较与排序 cmp_to_key(func)：把旧式比较函数转换为 key 函数（用于排序）。 单次计算 cached_property：把方法转换为只计算一次并缓存的属性。 函数组合与工具 reduce(func, iterable[, initializer])：聚合函数，把序列缩减为单一值。 singledispatch(func)：单分派泛型函数，根据参数类型调用不同实现。 singledispatchmethod(func)：方法版单分派。 5.1.3 原理 (How it works) 偏函数：通过闭包，把函数部分参数固定，生成新函数。 缓存：lru_cache 维护一个字典 + 双向链表，按调用顺序缓存结果。 函数包装：wraps 修改 __name__、__doc__ 等属性，保持原函数信息。 单分派：singledispatch 使用注册表存储“类型 → 函数”映射，运行时根据参数类型选择实现。 reduce：依次把迭代器的元素应用于函数，累积为一个结果。 5.1.4 应用 (Usage) 减少重复代码：用 partial 固定参数，生成专用函数。 性能优化：用 lru_cache 缓存计算结果，加速递归或重复计算。 保持装饰器友好性：用 wraps 保留原函数签名，避免调试混淆。 多态实现：用 singledispatch 让同一个函数根据输入类型执行不同逻辑。 数据处理：用 reduce 实现累积计算（如乘积、求和）。 5.1.5 举例 (Examples) 5.1.5.1 偏函数 from functools import partial def power(base, exp): return base ** exp square = partial(power, exp=2) print(square(5)) # 25 5.1.5.2 缓存结果 from functools import lru_cache @lru_cache(maxsize=128) def fib(n): if n &lt; 2: return n return fib(n-1) + fib(n-2) print(fib(35)) # 快速计算 5.1.5.3 保留元数据 from functools import wraps def my_decorator(func): @wraps(func) def wrapper(*args, **kwargs): print(&quot;Before call&quot;) return func(*args, **kwargs) return wrapper @my_decorator def hello(): &quot;&quot;&quot;Say hello&quot;&quot;&quot; print(&quot;Hello!&quot;) print(hello.__name__) # hello（而不是 wrapper） print(hello.__doc__) # Say hello 5.1.5.4 单分派函数 from functools import singledispatch @singledispatch def show(obj): print(&quot;Default:&quot;, obj) @show.register def _(obj: int): print(&quot;Integer:&quot;, obj) @show.register def _(obj: list): print(&quot;List:&quot;, obj) show(42) # Integer: 42 show([1, 2]) # List: [1, 2] show(&quot;hi&quot;) # Default: hi 5.1.5.5 reduce 聚合 from functools import reduce nums = [1, 2, 3, 4] product = reduce(lambda x, y: x * y, nums) print(product) # 24 5.1.6 辨析 (Misunderstanding) 误解 1：lru_cache 会无限缓存。 实际：默认 maxsize=128，超过会淘汰旧数据；若设 None 才无限缓存。 误解 2：partial 等价于普通函数封装。 实际：partial 更高效且可复用，能保留函数签名。 误解 3：reduce 已过时。 实际：Python 3 没移除，只是推荐用循环或生成式，reduce 在某些场景依然简洁。 误解 4：singledispatch 支持多参数类型匹配。 实际：只基于第一个参数的类型决定分派。 总结： functools 模块是 Python 函数增强工具箱： 固定参数 → partial 缓存 → lru_cache / cache 聚合计算 → reduce 多态 → singledispatch 装饰器辅助 → wraps 适合需要 高阶函数、性能优化、函数式编程风格 的场景。 5.2 itertools 模块 5.2.1 核心 (What) itertools 模块是 Python 的 迭代器工具库，提供高效的迭代器函数，用于创建、组合和操作数据流。 它的优势是：节省内存（惰性计算），并能简化复杂的迭代逻辑。 一句话总结：itertools 是 Python 的“迭代器积木”，用来拼装强大的循环。 5.2.2 组成结构 (Dimension) 常用函数大致分为三类： 无限迭代器 count(start=0, step=1)：无限递增序列。 cycle(iterable)：无限循环迭代。 repeat(elem[, times])：重复元素。 按需截取 accumulate(iterable, func)：累积计算（默认求和）。 chain(*iterables)：连接多个迭代器。 dropwhile(pred, iterable)：跳过满足条件的元素，直到第一个不满足为止。 takewhile(pred, iterable)：取出满足条件的元素。 islice(iterable, start, stop, step)：切片迭代器。 组合迭代器 product(*iterables, repeat=1)：笛卡尔积。 permutations(iterable, r)：全排列。 combinations(iterable, r)：无重复组合。 combinations_with_replacement(iterable, r)：可重复组合。 groupby(iterable, key)：按 key 分组。 5.2.3 原理 (How it works) itertools 内部全部基于 迭代器协议（实现 __iter__ 和 __next__）。 所有函数都返回迭代器，只有在遍历时才计算结果（惰性计算）。 许多函数是用 C 语言实现 的，效率远高于 Python 自己写的循环。 这种设计使它特别适合大数据流和内存敏感的场景。 5.2.4 应用 (Usage) 无限流生成：生成无限数列，常结合 islice 截取。 数据清洗：用 dropwhile / takewhile 控制数据范围。 统计与累积：用 accumulate 做累计和或累计乘积。 组合数学：生成排列、组合、笛卡尔积。 批处理数据：用 groupby 对序列分组。 多数据源合并：用 chain 把多个列表拼接成一个迭代器。 5.2.5 举例 (Examples) 5.2.5.1 无限迭代器 import itertools for i in itertools.islice(itertools.count(10, 2), 5): print(i) # 10 12 14 16 18 5.2.5.2 重复与循环 print(list(itertools.repeat(&quot;A&quot;, 3))) # [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;] for i, v in zip(range(5), itertools.cycle(&quot;AB&quot;)): print(v, end=&quot; &quot;) # A B A B A 5.2.5.3 累积计算 nums = [1, 2, 3, 4] print(list(itertools.accumulate(nums))) # [1, 3, 6, 10] 5.2.5.4 组合与排列 print(list(itertools.product(&quot;AB&quot;, &quot;12&quot;))) # [(&#39;A&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;2&#39;)] print(list(itertools.permutations(&quot;ABC&quot;, 2))) # [(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;A&#39;), ...] 5.2.5.5 分组 data = [(1, &quot;a&quot;), (1, &quot;b&quot;), (2, &quot;c&quot;), (2, &quot;d&quot;)] for k, g in itertools.groupby(data, key=lambda x: x[0]): print(k, list(g)) # 1 [(&#39;1&#39;, &#39;a&#39;), (1, &#39;b&#39;)] # 2 [(&#39;2&#39;, &#39;c&#39;), (2, &#39;d&#39;)] 5.2.6 辨析 (Misunderstanding) 误解 1：itertools 会生成完整结果。 实际：它返回迭代器，只有遍历时才计算。 误解 2：groupby 会自动全局分组。 实际：它只对连续相同 key 的元素分组，若要全局分组需先排序。 误解 3：count 会自动停止。 实际：它是无限生成器，必须配合 islice 等截断。 误解 4：排列组合只能用循环写。 实际：itertools 提供高效内置实现，远比手写快。 总结： itertools 是 Python 的 高效迭代器库，特点是： 惰性计算，节省内存； 提供组合数学和数据流处理工具； 适合数据清洗、统计分析、生成序列等场景。 和 functools 一起，可以写出非常简洁、强大的函数式风格代码。 5.3 collections 模块 5.3.1 核心 (What) collections 模块是 Python 的 高级数据容器库，提供比内置数据类型更强大的数据结构。 它在内置 list、dict、set、tuple 基础上做了功能扩展，常用于更高效、更直观地组织数据。 一句话总结：collections 模块是 Python 的“数据结构增强包”。 5.3.2 组成结构 (Dimension) 常用的类和函数： 计数器 Counter：统计元素出现次数，类似多重集。 双端队列 deque：高效的双端队列，支持从两端 O(1) 插入和删除。 默认字典 defaultdict：带默认值的字典，避免 KeyError。 有序字典 OrderedDict：保持插入顺序的字典（Python 3.7+ 内置 dict 也保持顺序）。 命名元组 namedtuple：带字段名的 tuple，像轻量级类。 链式映射 ChainMap：把多个字典逻辑上合并为一个。 用户自定义容器基类 UserDict、UserList、UserString：可继承并扩展。 5.3.3 原理 (How it works) Counter 内部继承自 dict，用元素作为 key，频次作为 value。 deque 基于 双向链表 或 块状数组 实现，支持高效两端操作。 defaultdict 通过传入 default_factory 来生成缺省值。 namedtuple 动态生成一个类，底层继承 tuple。 ChainMap 用链式结构保存多个字典，查询时逐个查找。 5.3.4 应用 (Usage) 数据统计：用 Counter 做词频统计、元素计数。 队列/栈：用 deque 实现先进先出（FIFO）或后进先出（LIFO）。 嵌套数据处理：用 defaultdict(list) 轻松组织嵌套字典。 轻量对象建模：用 namedtuple 定义不可变数据结构。 多配置管理：用 ChainMap 叠加不同层级的配置字典。 自定义容器：用 UserDict 等继承并扩展内置容器行为。 5.3.5 举例 (Examples) 5.3.5.1 Counter from collections import Counter words = [&quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;] count = Counter(words) print(count) # Counter({&#39;apple&#39;: 3, &#39;banana&#39;: 2, &#39;orange&#39;: 1}) print(count.most_common(1)) # [(&#39;apple&#39;, 3)] 5.3.5.2 deque from collections import deque d = deque([1, 2, 3]) d.appendleft(0) d.append(4) print(d) # deque([0, 1, 2, 3, 4]) d.pop() d.popleft() print(d) # deque([1, 2, 3]) 5.3.5.3 defaultdict from collections import defaultdict dd = defaultdict(list) dd[&quot;a&quot;].append(1) dd[&quot;a&quot;].append(2) print(dd) # defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;a&#39;: [1, 2]}) 5.3.5.4 namedtuple from collections import namedtuple Point = namedtuple(&quot;Point&quot;, [&quot;x&quot;, &quot;y&quot;]) p = Point(10, 20) print(p.x, p.y) # 10 20 print(isinstance(p, tuple)) # True 5.3.5.5 ChainMap from collections import ChainMap config_default = {&quot;color&quot;: &quot;blue&quot;, &quot;size&quot;: &quot;M&quot;} config_user = {&quot;size&quot;: &quot;L&quot;} cm = ChainMap(config_user, config_default) print(cm[&quot;size&quot;]) # L（优先用户配置） print(cm[&quot;color&quot;]) # blue 5.3.6 辨析 (Misunderstanding) 误解 1：Counter 是排序的。 实际：它本质是字典，顺序不保证；可用 .most_common() 排序。 误解 2：deque 和 list 效果一样。 实际：list 在头部插入/删除是 O(n)，deque 是 O(1)。 误解 3：OrderedDict 仍然有必要在 Python 3.7+。 实际：普通 dict 也保持插入顺序，OrderedDict 主要提供额外方法如 move_to_end()。 误解 4：namedtuple 和类完全一样。 实际：namedtuple 是不可变的，不能像类一样定义方法。 误解 5：ChainMap 会合并字典。 实际：它是逻辑组合，修改只作用于第一个字典。 总结： collections 模块提供 高效容器数据结构： 计数 → Counter 队列/栈 → deque 嵌套字典 → defaultdict 轻量对象 → namedtuple 多配置合并 → ChainMap 在数据处理、缓存结构、队列设计时非常实用。 "],["C6.html", "Chapter 6 并发与并行/轻量数据库 6.1 threading 模块 6.2 multiprocessing 模块 6.3 concurrent.futures 模块 6.4 sqlite3 模块 6.5 Python 标准库模块应用场景指南", " Chapter 6 并发与并行/轻量数据库 6.1 threading 模块 6.1.1 核心 (What) threading 模块是 Python 的 多线程编程接口，提供创建和管理线程的功能。 它让你能在同一进程内运行多个任务（线程），共享内存空间。 一句话总结：threading 模块让 Python 能并发执行多个任务（I/O 密集型最有效）。 6.1.2 组成结构 (Dimension) 主要组成部分： 线程类 Thread：表示一个线程，可继承或传入目标函数。 同步原语 Lock：互斥锁，防止多线程同时修改数据。 RLock：可重入锁，允许同一线程多次获取锁。 Semaphore：控制线程访问共享资源的数量。 Event：线程间通信的开关。 Condition：更复杂的条件变量，用于线程协作。 Barrier：等待一组线程都到达屏障点再继续。 工具方法 current_thread()：获取当前线程对象。 active_count()：当前活动线程数。 enumerate()：列出所有线程。 main_thread()：获取主线程。 6.1.3 原理 (How it works) 线程共享内存：所有线程在同一个进程内运行，变量是共享的。 GIL 限制：Python 的全局解释器锁（GIL）使得 同一时间只有一个线程执行 Python 字节码。 因此 threading 适合 I/O 密集型任务（如网络请求、文件读写）。 对于 CPU 密集型任务，推荐用 multiprocessing。 调度：由操作系统负责，Python 线程底层基于 OS 原生线程实现。 6.1.4 应用 (Usage) I/O 并发：爬虫、网络请求、日志处理。 后台任务：守护线程运行监控任务。 线程同步：多个线程安全访问共享资源。 并行等待：同时启动多个任务，等待全部完成。 6.1.5 举例 (Examples) 6.1.5.1 启动线程 import threading def worker(name): print(f&quot;线程 {name} 正在运行&quot;) t = threading.Thread(target=worker, args=(&quot;A&quot;,)) t.start() t.join() # 等待线程完成 6.1.5.2 使用继承创建线程 class MyThread(threading.Thread): def run(self): print(f&quot;线程 {self.name} 正在运行&quot;) t = MyThread() t.start() t.join() 6.1.5.3 锁的使用 lock = threading.Lock() counter = 0 def task(): global counter for _ in range(1000): with lock: # 确保同一时刻只有一个线程修改 counter counter += 1 threads = [threading.Thread(target=task) for _ in range(10)] for t in threads: t.start() for t in threads: t.join() print(&quot;最终结果:&quot;, counter) 6.1.5.4 事件通信 event = threading.Event() def waiter(): print(&quot;等待事件触发...&quot;) event.wait() print(&quot;事件已触发！&quot;) threading.Thread(target=waiter).start() event.set() # 通知线程继续执行 6.1.5.5 多线程并发 def worker(num): print(f&quot;任务 {num} 开始&quot;) import time; time.sleep(1) print(f&quot;任务 {num} 完成&quot;) threads = [threading.Thread(target=worker, args=(i,)) for i in range(5)] for t in threads: t.start() for t in threads: t.join() 6.1.6 辨析 (Misunderstanding) 误解 1：threading 能让 Python 程序多核并行。 实际：受 GIL 限制，无法真正并行执行 CPU 密集型代码。 误解 2：线程变量独立。 实际：线程共享内存，需要加锁保护。 误解 3：守护线程（daemon）一定会执行完。 实际：主线程结束时，daemon 线程会被直接终止。 误解 4：threading 比 multiprocessing 更快。 实际：I/O 场景更快，CPU 场景反而不如 multiprocessing。 总结： threading 模块适合 I/O 密集型并发： Thread → 运行任务 Lock/RLock → 保证线程安全 Event/Condition/Barrier → 线程协作 如果是 CPU 密集型任务，应该改用 multiprocessing。 6.2 multiprocessing 模块 6.2.1 核心 (What) multiprocessing 模块是 Python 的 多进程并行计算接口。 它通过启动多个独立的进程，绕过 GIL (全局解释器锁)，真正实现 CPU 多核并行。 一句话总结：multiprocessing 模块让 Python 能充分利用多核 CPU，适合 CPU 密集型任务。 6.2.2 组成结构 (Dimension) 主要组成部分： 进程管理 Process：创建独立进程，类似 threading.Thread。 Pool：进程池，批量管理进程。 进程间通信 (IPC) Queue：多进程安全队列。 Pipe：双向通信管道。 共享数据 Value、Array：跨进程共享变量。 Manager：支持 dict、list 等容器共享。 同步机制 Lock、Semaphore、Event、Condition：与 threading 类似，但作用于进程。 工具方法 cpu_count()：获取 CPU 核心数。 current_process()：获取当前进程对象。 set_start_method()：设置进程启动方式（spawn、fork、forkserver）。 6.2.3 原理 (How it works) multiprocessing 基于操作系统的 多进程机制： 每个子进程都有独立的 Python 解释器和内存空间。 进程之间数据不共享，必须通过 IPC（队列、管道、共享内存）通信。 绕过 GIL：每个进程独立执行字节码，可以同时运行在不同 CPU 核心。 进程池 (Pool)：维护固定数量的进程，避免频繁创建和销毁，提高效率。 6.2.4 应用 (Usage) CPU 密集型任务：数值计算、加密解密、图像/视频处理。 批量任务并行：任务分片后交给进程池。 数据生产-消费模型：一个进程生产数据，另一个消费。 多进程服务：并发处理请求，类似 Web 服务器的 worker 模式。 6.2.5 举例 (Examples) 6.2.5.1 基本进程 from multiprocessing import Process def worker(name): print(f&quot;进程 {name} 正在运行&quot;) if __name__ == &quot;__main__&quot;: p = Process(target=worker, args=(&quot;A&quot;,)) p.start() p.join() 6.2.5.2 使用进程池 from multiprocessing import Pool def square(x): return x * x if __name__ == &quot;__main__&quot;: with Pool(4) as pool: # 创建 4 个进程 results = pool.map(square, [1, 2, 3, 4, 5]) print(results) # [1, 4, 9, 16, 25] 6.2.5.3 进程间通信 (Queue) from multiprocessing import Process, Queue def producer(q): q.put(&quot;data&quot;) def consumer(q): print(&quot;消费:&quot;, q.get()) if __name__ == &quot;__main__&quot;: q = Queue() p1 = Process(target=producer, args=(q,)) p2 = Process(target=consumer, args=(q,)) p1.start(); p2.start() p1.join(); p2.join() 6.2.5.4 共享数据 (Value, Array) from multiprocessing import Process, Value, Array def f(n, a): n.value += 1 for i in range(len(a)): a[i] = -a[i] if __name__ == &quot;__main__&quot;: num = Value(&#39;i&#39;, 0) arr = Array(&#39;i&#39;, range(5)) p = Process(target=f, args=(num, arr)) p.start(); p.join() print(num.value) # 1 print(list(arr)) # [0, -1, -2, -3, -4] 6.2.5.5 进程同步 (Lock) from multiprocessing import Process, Lock def task(lock, n): with lock: print(f&quot;进程 {n} 获得锁&quot;) if __name__ == &quot;__main__&quot;: lock = Lock() for i in range(3): Process(target=task, args=(lock, i)).start() 6.2.6 辨析 (Misunderstanding) 误解 1：multiprocessing 和 threading 完全相同。 实际：threading 共享内存但受 GIL 限制；multiprocessing 独立内存，可并行 CPU 任务。 误解 2：进程间数据共享像线程一样简单。 实际：进程必须通过队列、管道、共享内存通信，复杂度更高。 误解 3：进程池比多线程一定更快。 实际：创建进程开销更大，小任务反而可能更慢。 误解 4：跨平台代码不用考虑启动方式。 实际：Windows 默认 spawn，Linux 默认 fork，某些代码需加保护： if __name__ == &quot;__main__&quot;: ... 总结： multiprocessing 模块是 Python 实现真正并行计算 的利器： Process → 单独进程 Pool → 批量任务 Queue / Pipe → 通信 Value / Array / Manager → 共享数据 适合 CPU 密集型任务，而 I/O 密集型仍推荐用 threading 或 asyncio。 6.3 concurrent.futures 模块 6.3.1 核心 (What) concurrent.futures 模块是 Python 提供的 高级并发编程接口，封装了 threading 和 multiprocessing 的常见用法。 它通过 Executor（执行器）对象来管理任务（函数调用）的提交与执行，提供统一的 API。 一句话总结：concurrent.futures 是 Python 并发的“简化接口”，让多线程、多进程调用更现代、更好用。 6.3.2 组成结构 (Dimension) 主要组件： 执行器（Executor） ThreadPoolExecutor：基于线程池，适合 I/O 密集型任务。 ProcessPoolExecutor：基于进程池，适合 CPU 密集型任务。 Future 对象 表示一个“未来可能完成的任务”，用于获取结果或异常。 方法： .result()：获取任务结果（阻塞）。 .done()：任务是否完成。 .exception()：任务异常。 .add_done_callback()：任务完成时的回调。 工具方法 as_completed(fs)：迭代已完成的 Future。 wait(fs, timeout=None, return_when=ALL_COMPLETED)：等待一组任务完成。 6.3.3 原理 (How it works) Executor 管理线程池或进程池，负责任务调度。 当调用 submit(fn, *args) 或 map(fn, iterable) 时： 任务会放入任务队列，由池中的线程/进程异步执行。 返回 Future 对象，表示该任务的执行状态。 Future 充当结果的占位符，可以在任务完成后获取结果或异常。 与 threading/multiprocessing 相比： 开发者无需手动管理线程/进程，只需提交任务。 6.3.4 应用 (Usage) I/O 并发：用 ThreadPoolExecutor 同时执行多个网络请求或文件操作。 CPU 并行：用 ProcessPoolExecutor 并行计算大规模数值。 批量任务调度：提交一组函数，按完成顺序收集结果。 异步模式：结合 Future 回调机制，实现事件驱动逻辑。 6.3.5 举例 (Examples) 6.3.5.1 基本用法（线程池） from concurrent.futures import ThreadPoolExecutor def task(n): return n * n with ThreadPoolExecutor(max_workers=3) as executor: futures = [executor.submit(task, i) for i in range(5)] for f in futures: print(f.result()) 6.3.5.2 使用进程池 from concurrent.futures import ProcessPoolExecutor def fib(n): if n &lt; 2: return n return fib(n-1) + fib(n-2) with ProcessPoolExecutor() as executor: results = executor.map(fib, [20, 25, 30]) print(list(results)) 6.3.5.3 as_completed 收集结果 from concurrent.futures import ThreadPoolExecutor, as_completed import time def work(x): time.sleep(x) return x with ThreadPoolExecutor(max_workers=3) as executor: futures = [executor.submit(work, i) for i in [3, 1, 2]] for f in as_completed(futures): print(&quot;完成任务:&quot;, f.result()) 6.3.5.4 wait 等待任务 from concurrent.futures import ThreadPoolExecutor, wait def task(n): return n with ThreadPoolExecutor() as executor: futures = [executor.submit(task, i) for i in range(5)] done, not_done = wait(futures) print(&quot;完成的:&quot;, [f.result() for f in done]) 6.3.5.5 Future 回调 from concurrent.futures import ThreadPoolExecutor def task(n): return n * 2 def when_done(future): print(&quot;回调: 结果 =&quot;, future.result()) with ThreadPoolExecutor() as executor: f = executor.submit(task, 10) f.add_done_callback(when_done) 6.3.6 辨析 (Misunderstanding) 误解 1：ThreadPoolExecutor 能突破 GIL 做 CPU 并行。 实际：仍受 GIL 限制，适合 I/O 密集型，不适合 CPU 密集型。 误解 2：executor.map 和内置 map 一样。 实际：executor.map 是并发执行，结果按提交顺序返回，而不是完成顺序。 误解 3：Future.result() 总是立即返回。 实际：它会阻塞直到任务完成。 误解 4：线程池/进程池数量越多越快。 实际：过多线程会增加上下文切换，过多进程会增加内存消耗。 总结： concurrent.futures 是 Python 并发编程的现代接口： ThreadPoolExecutor → I/O 密集型 ProcessPoolExecutor → CPU 密集型 Future → 任务结果占位符 as_completed / wait → 批量任务管理 相比 threading 和 multiprocessing，它更简洁、更安全，适合绝大多数并发需求。 6.4 sqlite3 模块 6.4.1 核心 (What) sqlite3 模块是 Python 内置的 轻量级数据库接口，用于操作 SQLite 数据库。 SQLite 是一种嵌入式关系型数据库，数据存储在单个文件中，无需单独的服务器进程。 一句话总结：sqlite3 让你能用 SQL 在本地文件中管理数据，适合小型应用和原型开发。 6.4.2 组成结构 (Dimension) 主要组成部分： 连接与游标 sqlite3.connect(path)：建立数据库连接。 cursor()：获取游标对象，用于执行 SQL。 SQL 执行 execute(sql, params)：执行 SQL 语句。 executemany(sql, seq_of_params)：批量执行。 executescript(sql_script)：执行多条 SQL 脚本。 事务管理 自动启用事务，需 commit() 提交或 rollback() 回滚。 结果获取 fetchone()：获取一行。 fetchall()：获取所有行。 fetchmany(n)：获取多行。 高级功能 row_factory：自定义行对象（如字典）。 参数占位符 ?：防止 SQL 注入。 支持 :memory: 内存数据库。 6.4.3 原理 (How it works) sqlite3 模块基于 SQLite C 库 实现，所有功能都嵌入在 Python 内部，无需安装额外软件。 存储模型：数据库是一个单独文件（或内存数据库），适合单用户/小型应用。 事务机制：默认自动开启事务，需要显式提交。 线程安全：SQLite 本身支持多线程，但写入是串行的。 6.4.4 应用 (Usage) 本地小型数据库：记账本、笔记应用、轻量级 CMS。 数据缓存：存储临时数据，避免重复计算或请求。 原型开发：快速搭建数据库原型，后期可迁移到 MySQL/PostgreSQL。 单文件应用：所有数据都放在一个 .db 文件里，便于分发。 6.4.5 举例 (Examples) 6.4.5.1 创建数据库与表 import sqlite3 conn = sqlite3.connect(&quot;example.db&quot;) cursor = conn.cursor() cursor.execute(&quot;&quot;&quot; CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY, name TEXT, age INTEGER ) &quot;&quot;&quot;) conn.commit() 6.4.5.2 插入数据 cursor.execute(&quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;, (&quot;Alice&quot;, 25)) cursor.executemany(&quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;, [ (&quot;Bob&quot;, 30), (&quot;Charlie&quot;, 28) ]) conn.commit() 6.4.5.3 查询数据 cursor.execute(&quot;SELECT * FROM users WHERE age &gt; ?&quot;, (20,)) rows = cursor.fetchall() for row in rows: print(row) 6.4.5.4 使用 row_factory 返回字典 conn.row_factory = sqlite3.Row cursor = conn.cursor() cursor.execute(&quot;SELECT * FROM users&quot;) for row in cursor.fetchall(): print(dict(row)) 6.4.5.5 内存数据库 conn = sqlite3.connect(&quot;:memory:&quot;) # 不落盘，存储在内存中 6.4.6 辨析 (Misunderstanding) 误解 1：SQLite 可以完全替代大型数据库。 实际：SQLite 适合小规模数据（几 GB），高并发/分布式场景应使用 MySQL/PostgreSQL。 误解 2：插入数据后会自动保存。 实际：必须显式 commit() 才能持久化。 误解 3：可以像多线程队列一样同时写入。 实际：SQLite 支持多读单写，多个写操作会排队。 误解 4：SQL 语句可以用 Python f-string 拼接。 实际：必须用参数占位符 ?，否则有 SQL 注入风险。 总结： sqlite3 模块是 Python 内置的 零配置数据库解决方案： 轻量、易用、单文件存储。 适合小型应用、本地缓存、教学场景。 但不适合高并发和分布式环境。 6.5 Python 标准库模块应用场景指南 6.5.1 操作系统相关 什么时候用？ 当你需要操作文件、路径、系统环境时。 os → 管理目录、文件，获取环境变量 sys → 与 Python 解释器本身交互（退出程序、读参数） pathlib → 更现代的路径处理 📌 场景： 读取环境变量（os.environ） 获取当前路径并拼接文件（pathlib.Path） 程序异常时退出（sys.exit） 6.5.2 数据存储格式 什么时候用？ 当你要 保存/读取 不同格式的数据时。 json → 配置、API 传输（人机都能读） csv → 表格、数据导出（Excel 可打开） configparser → INI 格式的配置文件 📌 场景： 保存数据到 JSON（用户配置） 导出爬虫结果到 CSV 读写配置文件 settings.ini 6.5.3 时间与日期 什么时候用？ 当你处理 时间戳、日期计算、定时任务 时。 time → 秒级时间戳、延时 datetime → 日期时间运算（加减天数、格式化） calendar → 日历、闰年、星期几 📌 场景： 打印日志时加时间戳 定时任务（sleep 10 秒） 判断 2024 年是不是闰年 6.5.4 日志系统 什么时候用？ 当你需要 替代 print，保存运行记录 时。 logging → 可设置日志等级（INFO/ERROR），写到文件/控制台 📌 场景： 调试阶段输出 debug 信息 生产系统保存运行日志 6.5.5 文本处理 什么时候用？ 当你要在字符串里找规律、提取信息时。 re → 正则表达式，查找/替换/提取 📌 场景： 从网页提取邮箱/手机号 替换掉文本里的特殊符号 6.5.6 命令行工具 什么时候用？ 当你要写一个可以从终端运行的脚本时。 argparse → 解析命令行参数，自动生成帮助文档 📌 场景： python script.py data.txt --verbose 制作小工具，接收输入文件路径和参数 6.5.7 系统命令 什么时候用？ 当你需要调用系统里的其他程序时。 subprocess → 运行外部命令/脚本，并获取结果 场景： 用 Python 调用 ls 或 ping 自动运行 shell 脚本 6.5.8 高级数据结构与工具 什么时候用？ 当内置 list/dict 不够用，需要更高级的数据结构时。 functools → 偏函数、缓存（lru_cache） itertools → 组合、排列、无限迭代器 collections → 计数器、双端队列、默认字典 场景： 统计单词出现次数（Counter） 高效队列（deque） 生成排列组合（itertools.permutations） 缓存函数结果，加快计算（lru_cache） 6.5.9 并发与并行 什么时候用？ 当你的程序需要同时做多件事时。 threading → 多线程（I/O 密集，如下载文件） multiprocessing → 多进程（CPU 密集，如大规模计算） concurrent.futures → 统一接口，更好用的线程池/进程池 📌 场景： 爬虫同时抓 100 个网页（threading） 并行计算大数组（multiprocessing） 用线程池批量跑任务（concurrent.futures） 6.5.10 数据存储 什么时候用？ 当你需要比 CSV/JSON 更高级，但又不想搭数据库服务器时。 sqlite3 → 轻量级数据库，单文件存储 📌 场景： 本地记账本 数据缓存（查询比 CSV 快） 小型项目的数据存储 "],["data-processing.html", "Chapter 7 数据处理与计算 7.1 NumPy 模块 7.2 Pandas 模块 7.3 Matplotlib 模块 7.4 Seaborn 模块", " Chapter 7 数据处理与计算 7.1 NumPy 模块 7.1.1 核心 (What) NumPy（Numerical Python）是 Python 的 科学计算基础库。 它提供了 多维数组对象（ndarray），以及高效的数学运算工具。 一句话总结：NumPy 是 Python 里处理数值和矩阵的底层引擎，几乎所有科学计算/机器学习库（如 Pandas、TensorFlow、PyTorch）都依赖它。 7.1.2 组成结构 (Dimension) NumPy 的主要功能可以分为以下几个方面： 核心对象 ndarray：多维数组，核心数据结构。 数组创建 np.array()、np.zeros()、np.ones()、np.arange()、np.linspace()。 数组操作 索引 &amp; 切片：与 Python 列表类似，但更强大。 形状操作：reshape()、transpose()、flatten()。 数学运算 基础：加减乘除、开方、指数、对数。 统计：均值、标准差、最大/最小值。 线性代数：矩阵乘法（dot / @）、逆矩阵、特征值。 广播机制 支持不同形状的数组之间运算。 随机数 np.random 模块：生成随机数、正态分布、洗牌。 7.1.3 原理 (How it works) 底层 C 实现：NumPy 的数组存储在 连续的内存块 中，计算用 C 实现，比 Python 列表快数十倍。 矢量化运算：避免 Python 的循环，直接在底层 C 里并行计算。 广播：小数组会自动扩展为大数组，支持不同维度的数据运算。 接口统一：很多科学计算库直接调用 NumPy 的 API。 7.1.4 应用 (Usage) 数值计算：矩阵运算、科学公式实现。 数据处理：数据清洗、批量运算。 机器学习/深度学习底层：作为 TensorFlow、PyTorch 的核心数据结构。 统计分析：随机数生成、概率分布模拟。 图像处理：图像像素矩阵化。 7.1.5 举例 (Examples) 7.1.5.1 创建数组 import numpy as np a = np.array([1, 2, 3]) # 一维数组 b = np.zeros((2, 3)) # 2x3 全 0 矩阵 c = np.ones((2, 2)) # 2x2 全 1 矩阵 d = np.arange(0, 10, 2) # [0, 2, 4, 6, 8] e = np.linspace(0, 1, 5) # 等分 [0,1] → [0. , 0.25, 0.5 , 0.75, 1. ] 7.1.5.2 数学运算 x = np.array([1, 2, 3]) y = np.array([4, 5, 6]) print(x + y) # [5 7 9] print(x * y) # [ 4 10 18] print(np.dot(x, y)) # 32 (点积) 7.1.5.3 矩阵运算 m1 = np.array([[1, 2], [3, 4]]) m2 = np.array([[5, 6], [7, 8]]) print(m1 @ m2) # 矩阵乘法 7.1.5.4 统计分析 data = np.array([1, 2, 3, 4, 5]) print(np.mean(data)) # 平均值 3.0 print(np.std(data)) # 标准差 print(np.max(data)) # 最大值 7.1.5.5 随机数 np.random.seed(0) print(np.random.rand(3)) # 3 个 [0,1) 随机数 print(np.random.randint(1, 10, size=(2, 2))) # 2x2 随机整数矩阵 7.1.6 辨析 (Misunderstanding) 误解 1：NumPy 和 Python list 差不多。 实际：NumPy 数组是连续内存 + 矢量化运算，性能比 list 高很多。 误解 2：必须用循环遍历数组。 实际：应该用 矢量化操作，避免 for 循环。 误解 3：NumPy 只能做矩阵。 实际：NumPy 还能做统计分析、随机数生成、傅里叶变换。 误解 4：NumPy 跟 Pandas 重复。 实际：Pandas 底层依赖 NumPy，前者更适合表格型数据。 总结： NumPy 是 Python 科学计算的基础库： ndarray → 多维数组 矢量化 → 高效运算 广播 → 灵活操作 随机数 &amp; 统计 → 数据分析常用 学 Python 数据分析 / AI，NumPy 一定是第一步。 7.2 Pandas 模块 7.2.1 核心 (What) Pandas 是 Python 的 数据分析库，基于 NumPy 构建。 它提供了两大核心数据结构： Series：一维带标签的数组。 DataFrame：二维带行列标签的表格（类似 Excel / SQL 表）。 一句话总结：Pandas 就是 Python 里的 Excel + SQL，专门处理结构化数据。 7.2.2 组成结构 (Dimension) Pandas 的主要功能： 数据结构 Series：一维数组（带索引）。 DataFrame：二维表格（行索引 + 列名）。 数据导入导出 read_csv() / to_csv() read_excel() / to_excel() read_sql() / to_sql() 数据选择与操作 行列选择：.loc[]、.iloc[]。 筛选：布尔条件。 增删改列：df[\"new\"] = ...、drop()。 数据处理 缺失值：isna()、fillna()。 排序：sort_values()。 去重：drop_duplicates()。 统计与计算 聚合：mean()、sum()、groupby()。 透视表：pivot_table()。 时间序列：内置日期处理。 可视化支持 df.plot()（基于 Matplotlib）。 7.2.3 原理 (How it works) Pandas 底层基于 NumPy ndarray，所以支持高效的矢量化运算。 Series 和 DataFrame 给数组加上了 标签（索引），更像数据库表格。 通过 Cython/C 优化，比纯 Python 操作快很多。 兼容多种数据源（CSV、Excel、SQL、JSON 等）。 7.2.4 应用 (Usage) 数据分析：读取 CSV/Excel，清洗整理后分析。 数据预处理：机器学习前的数据整理。 统计汇总：分组、聚合、透视表。 报表输出：处理数据后导出 Excel/CSV。 时间序列：金融/气象/传感器数据。 7.2.5 举例 (Examples) 7.2.5.1 创建 Series 和 DataFrame import pandas as pd s = pd.Series([10, 20, 30], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) print(s) df = pd.DataFrame({ &quot;name&quot;: [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;], &quot;age&quot;: [25, 30, 35], &quot;score&quot;: [85, 90, 95] }) print(df) 7.2.5.2 读取和保存 df = pd.read_csv(&quot;data.csv&quot;) # 从 CSV 读取 df.to_excel(&quot;output.xlsx&quot;) # 保存为 Excel 7.2.5.3 数据选择 print(df[&quot;name&quot;]) # 选择列 print(df.loc[0]) # 按标签选行 print(df.iloc[1:3]) # 按位置选行 print(df[df[&quot;age&quot;] &gt; 28]) # 筛选 7.2.5.4 缺失值处理 df[&quot;score&quot;].fillna(df[&quot;score&quot;].mean(), inplace=True) 7.2.5.5 分组聚合 grouped = df.groupby(&quot;age&quot;)[&quot;score&quot;].mean() print(grouped) 7.2.5.6 透视表 pivot = df.pivot_table(values=&quot;score&quot;, index=&quot;age&quot;, aggfunc=&quot;mean&quot;) print(pivot) 7.2.6 辨析 (Misunderstanding) 误解 1：Pandas = NumPy。 实际：Pandas 基于 NumPy，但更适合 带标签的表格数据。 误解 2：DataFrame 就是 Excel。 实际：功能更强大（支持 SQL 风格操作、分组聚合、时间序列）。 误解 3：Pandas 操作一定快。 实际：Pandas 适合中小规模数据，超大数据要用 Dask、PySpark。 误解 4：必须学完 SQL 才能用 Pandas。 实际：Pandas 本身就能做 SQL 类操作。 总结： Pandas 是 Python 数据分析的核心工具： Series / DataFrame → 表格数据结构 read_csv / read_excel → 数据导入导出 groupby / pivot_table → 数据聚合 缺失值处理 / 筛选 / 排序 → 数据清洗 它让 Python 拥有 Excel + SQL 的功能，几乎是数据科学必学库。 7.3 Matplotlib 模块 7.3.1 核心 (What) Matplotlib 是 Python 的 基础绘图库，几乎所有数据可视化库都依赖它。 它能绘制折线图、柱状图、散点图、直方图等常见图表。 一句话总结：Matplotlib 是 Python 的“画布”，几乎所有图都能用它画。 7.3.2 组成结构 (Dimension) 核心对象：Figure（图）、Axes（坐标轴） 常用接口： pyplot：类似 MATLAB 风格，快速画图（plt.plot、plt.bar） 面向对象接口：更灵活，推荐在复杂图表里用 7.3.3 原理 (How it works) 底层基于 绘图库 (Agg, Tk, Qt 等后端) 渲染图像 提供一套 状态机模式（plt.plot() 会作用在当前图） 可保存为 PNG、PDF、SVG 等格式 7.3.4 应用 (Usage) 基础绘图：折线、柱状、散点、直方图 自定义图表：设置标题、坐标轴、颜色、标注 与 NumPy/Pandas 配合：快速展示数据趋势 7.3.5 举例 (Examples) import matplotlib.pyplot as plt import numpy as np x = np.linspace(0, 10, 100) y = np.sin(x) plt.plot(x, y, label=&quot;sin(x)&quot;) plt.title(&quot;折线图示例&quot;) plt.xlabel(&quot;x 轴&quot;) plt.ylabel(&quot;y 轴&quot;) plt.legend() plt.show() 7.3.6 辨析 (Misunderstanding) 误解 1：Matplotlib 只能画简单图。 实际：几乎所有类型都能画，但代码可能比较繁琐。 误解 2：和 Excel 画图一样简单。 实际：需要理解“画布/坐标轴”结构。 误解 3：Pandas 自带 df.plot() 不用 Matplotlib。 实际：Pandas 内部就是调用 Matplotlib。 7.4 Seaborn 模块 7.4.1 核心 (What) Seaborn 是基于 Matplotlib 的 高级绘图库，主打 统计图表。 它自带更美观的样式，能快速绘制分布图、相关性图、热力图。 一句话总结：Seaborn 是 Matplotlib 的美化与增强版，专注统计可视化。 7.4.2 组成结构 (Dimension) 数据输入：直接支持 Pandas DataFrame 常见函数： sns.lineplot() 折线图 sns.barplot() 条形图 sns.scatterplot() 散点图 sns.heatmap() 热力图 sns.pairplot() 成对关系图 7.4.3 原理 (How it works) 底层还是调用 Matplotlib 自动集成 统计运算（比如平均值、置信区间） 自带更优雅的默认主题 7.4.4 应用 (Usage) 数据探索 (EDA)：看变量分布、变量关系 统计分析：分组均值、回归拟合 美化图表：快速得到出版级图形 7.4.5 举例 (Examples) import seaborn as sns import matplotlib.pyplot as plt import pandas as pd # 样例数据 df = pd.DataFrame({ &quot;x&quot;: [1, 2, 3, 4, 5], &quot;y&quot;: [2, 3, 5, 7, 11], &quot;category&quot;: [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;B&quot;] }) # 散点图 sns.scatterplot(data=df, x=&quot;x&quot;, y=&quot;y&quot;, hue=&quot;category&quot;) plt.title(&quot;Seaborn 散点图&quot;) plt.show() # 热力图 corr = df.corr(numeric_only=True) sns.heatmap(corr, annot=True, cmap=&quot;coolwarm&quot;) plt.title(&quot;相关性热力图&quot;) plt.show() 7.4.6 辨析 (Misunderstanding) 误解 1：Seaborn 可以完全替代 Matplotlib。 实际：复杂图表仍需要 Matplotlib 配合。 误解 2：Seaborn 只能画统计图。 实际：它对常见图表也支持，只是更偏向数据科学场景。 误解 3：Seaborn 比 Matplotlib 慢很多。 实际：差别不大，底层都依赖 Matplotlib。 "],["C8.html", "Chapter 8 网络与Web 8.1 Requests 模块 8.2 Flask 模块 8.3 FastAPI 模块 8.4 Django 模块", " Chapter 8 网络与Web 8.1 Requests 模块 8.1.1 核心 (What) Requests 是 Python 最常用的 HTTP 请求库，用于和网站、API 进行交互。 它让你能方便地发送 GET / POST / PUT / DELETE 请求，处理响应数据。 一句话总结：Requests 就是 Python 的浏览器，帮你和互联网对话。 8.1.2 组成结构 (Dimension) 主要功能包括： HTTP 请求方法 get()：获取数据 post()：提交表单或 JSON put()：更新资源 delete()：删除资源 请求参数 params：URL 查询参数 data：表单数据 json：JSON 数据 headers：请求头 响应对象 .status_code：状态码 .text：响应文本 .json()：解析 JSON .content：字节流（下载文件） 会话管理 requests.Session()：保持 Cookie、Header 等 其他功能 超时设置：timeout=5 文件上传：files 认证：auth SSL 验证：verify=False 8.1.3 原理 (How it works) 底层基于 Python 的 http.client 和 urllib3，进行了更高层封装。 通过 HTTP 协议 与服务器通信，发送请求报文，接收响应报文。 对开发者屏蔽了繁琐的细节，让调用更简洁。 8.1.4 应用 (Usage) 调用 API：如天气查询、股票数据接口 网页爬取：获取网页 HTML 自动化登录：模拟表单提交 文件下载：从网络保存图片/文档 测试接口：调试 RESTful 服务 8.1.5 举例 (Examples) 8.1.5.1 GET 请求 import requests response = requests.get(&quot;https://api.github.com&quot;) print(response.status_code) # 200 print(response.json()) # JSON 响应 8.1.5.2 带参数的请求 payload = {&quot;q&quot;: &quot;python&quot;, &quot;sort&quot;: &quot;stars&quot;} response = requests.get(&quot;https://api.github.com/search/repositories&quot;, params=payload) print(response.url) # 实际请求的 URL 8.1.5.3 POST 请求 data = {&quot;username&quot;: &quot;test&quot;, &quot;password&quot;: &quot;123&quot;} response = requests.post(&quot;https://httpbin.org/post&quot;, data=data) print(response.json()) 8.1.5.4 JSON 请求 response = requests.post(&quot;https://httpbin.org/post&quot;, json={&quot;key&quot;: &quot;value&quot;}) print(response.json()) 8.1.5.5 文件下载 url = &quot;https://httpbin.org/image/png&quot; response = requests.get(url) with open(&quot;image.png&quot;, &quot;wb&quot;) as f: f.write(response.content) 8.1.5.6 会话保持 session = requests.Session() session.get(&quot;https://httpbin.org/cookies/set/sessionid/123&quot;) r = session.get(&quot;https://httpbin.org/cookies&quot;) print(r.text) # 包含 sessionid=123 8.1.6 辨析 (Misunderstanding) 误解 1：Requests 只能获取网页。 实际：它主要用于 API 调用，获取 JSON 数据更常见。 误解 2：用 requests.get 就一定成功。 实际：需要检查 .status_code，非 200 表示失败。 误解 3：.text 和 .json() 一样。 实际：.text 是字符串，.json() 会自动解析 JSON。 误解 4：必须手动处理 Cookie。 实际：用 Session 就能自动保持。 总结： requests 模块是 Python 最常用的 网络请求工具： 简单易用：get / post / put / delete 适合调用 API、爬取网页、自动化测试 比标准库 urllib 更简洁 8.2 Flask 模块 8.2.1 核心 (What) Flask 是一个 轻量级 Web 框架，核心小巧、灵活，常被称为“微框架”。 它只提供 Web 的最基本功能（路由、请求处理），其他功能通过扩展实现。 一句话总结：Flask 是 “乐高积木”，核心小，但能自由拼接出各种 Web 应用。 8.2.2 组成结构 (Dimension) 核心 Flask 应用对象 路由 (@app.route) 请求 (request) / 响应 (Response) 扩展（可选） 数据库：Flask-SQLAlchemy 表单：Flask-WTF 用户认证：Flask-Login 8.2.3 原理 (How it works) 基于 WSGI（Python Web 服务器网关接口） 内置轻量服务器（调试用），生产一般用 Gunicorn、uWSGI 部署 核心理念：保持简单，其他功能交给扩展 8.2.4 应用 (Usage) 小型网站、博客 API 原型设计 教学与快速试验 8.2.5 举例 (Example) from flask import Flask app = Flask(__name__) @app.route(&quot;/&quot;) def hello(): return &quot;Hello Flask!&quot; if __name__ == &quot;__main__&quot;: app.run(debug=True) 8.2.6 辨析 (Misunderstanding) 误解 1：Flask 功能太少，做不了大项目。 实际：大型应用完全可以，只是需要组合更多扩展。 误解 2：Flask 自带数据库。 实际：需要安装扩展，比如 SQLAlchemy。 8.3 FastAPI 模块 8.3.1 核心 (What) FastAPI 是一个 现代化 Web 框架，主打 快速开发 API，基于 Python 类型注解 自动生成文档。 特点是 快（性能接近 Node.js/Go）、好用（自动文档）、现代（异步支持）。 一句话总结：FastAPI 是 “新时代 API 框架”，特别适合做后端接口。 8.3.2 组成结构 (Dimension) 核心 FastAPI 应用对象 路由 (@app.get, @app.post) 请求参数 → 自动验证（基于 pydantic） 响应 → 自动生成 JSON 自动文档 Swagger UI (/docs) ReDoc (/redoc) 8.3.3 原理 (How it works) 基于 ASGI（异步服务器网关接口），支持高并发 使用 Starlette 处理底层 Web 逻辑 使用 Pydantic 处理数据验证和序列化 内置异步支持（async def） 8.3.4 应用 (Usage) RESTful API 微服务后端 机器学习/AI 模型部署接口 高并发应用（实时请求、WebSocket） 8.3.5 举例 (Example) from fastapi import FastAPI app = FastAPI() @app.get(&quot;/&quot;) async def hello(): return {&quot;message&quot;: &quot;Hello FastAPI!&quot;} # 启动方式： uvicorn main:app --reload 打开浏览器访问 http://127.0.0.1:8000/docs 会看到自动生成的 Swagger API 文档。 8.3.6 辨析 (Misunderstanding) 误解 1：FastAPI 只能写异步代码。 实际：同步代码也支持。 误解 2：FastAPI 比 Flask 复杂很多。 实际：上手成本差不多，自动文档反而更省心。 误解 3：FastAPI 更快，所以总比 Flask 好。 实际：小项目 Flask 更轻便，FastAPI 更适合大规模 API。 8.4 Django 模块 8.4.1 核心 (What) Django 是一个 全功能 Web 框架，号称 “The Web framework for perfectionists with deadlines”。 它内置了 数据库 ORM、认证系统、模板引擎、后台管理 等功能，开发大型网站时几乎开箱即用。 一句话总结：Django 是 “大而全的企业级框架”，适合做完整的网站和后台系统。 8.4.2 组成结构 (Dimension) Django 的主要组成部分： MVC/MVT 架构 Model（模型，数据库 ORM） View（视图，处理逻辑） Template（模板，渲染 HTML） 内置功能 ORM（对象关系映射） 模板系统（动态生成网页） URL 路由 用户认证与权限 后台管理（Admin） 表单系统 扩展生态 Django REST framework（DRF）：构建 API 各类第三方插件：支付、CMS、OAuth 等 8.4.3 原理 (How it works) 基于 WSGI（同步） 或 ASGI（新版本支持异步） 严格的 配置 + 约定：项目有清晰的文件夹结构 ORM 负责把 Python 类与数据库表自动对应 内置管理后台可以直接操作数据库 8.4.4 应用 (Usage) 大型网站（社交平台、内容管理系统 CMS） 企业后台（管理系统、ERP、CRM） 快速上线的 MVP 产品 需要复杂用户权限/认证 的项目 8.4.5 举例 (Example) 8.4.5.1 创建项目 django-admin startproject mysite cd mysite python manage.py runserver 8.4.5.2 定义模型 # myapp/models.py from django.db import models class User(models.Model): name = models.CharField(max_length=50) age = models.IntegerField() 8.4.5.3 定义视图 # myapp/views.py from django.http import HttpResponse def hello(request): return HttpResponse(&quot;Hello Django!&quot;) 8.4.5.4 定义路由 # mysite/urls.py from django.urls import path from myapp.views import hello urlpatterns = [ path(&quot;&quot;, hello), ] 访问 http://127.0.0.1:8000/ → Hello Django! 8.4.6 辨析 (Misunderstanding) 误解 1：Django 太笨重，不适合小项目。 实际：小项目用起来确实比 Flask/FastAPI 繁琐，但也能快速生成后台。 误解 2：Django 和 Flask 一样是“微框架”。 实际：Django 是“全家桶”，自带 ORM、后台管理；Flask 是“空壳”，需要拼插件。 误解 3：Django 不支持 API。 实际：配合 Django REST Framework (DRF)，是最常用的 API 框架之一。 误解 4：Django 太老了，性能差。 实际：新版本支持异步，性能有提升，但高并发场景仍不如 FastAPI。 、 "],["C9.html", "Chapter 9 爬虫 9.1 BeautifulSoup4 模块 9.2 lxml 模块", " Chapter 9 爬虫 9.1 BeautifulSoup4 模块 9.1.1 核心 (What) BeautifulSoup4 (bs4) 是一个 HTML/XML 解析库，作用是把网页源码转成一个“树形结构”，然后你就能用标签名、属性来提取内容。 一句话总结：BeautifulSoup 就像 “HTML 解析放大镜”，专门帮你在网页里找信息。 9.1.2 组成结构 (Dimension) 核心对象 BeautifulSoup：解析器对象 Tag：HTML 标签对象 NavigableString：文本内容 Comment：注释节点 查找方法 find() / find_all()：按标签名/属性查找 select()：支持 CSS 选择器（更灵活） 9.1.3 原理 (How it works) BeautifulSoup 不会请求网页，它只解析 HTML 字符串 内部可以调用不同的解析器： Python 内置 html.parser（默认） lxml（更快，需安装） html5lib（最完整，最慢） 9.1.4 应用 (Usage) 爬虫：从网页中提取数据（标题、链接、图片等） HTML/XML 文档解析：读取本地 HTML 文件并提取内容 9.1.5 举例 (Example) from bs4 import BeautifulSoup html = &quot;&quot;&quot; &lt;html&gt;&lt;head&gt;&lt;title&gt;示例页面&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;title&quot;&gt;欢迎&lt;/h1&gt; &lt;a href=&quot;https://example.com&quot;&gt;链接&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; &quot;&quot;&quot; soup = BeautifulSoup(html, &quot;lxml&quot;) print(soup.title.text) # 示例页面 print(soup.find(&quot;h1&quot;).text) # 欢迎 print(soup.find(&quot;a&quot;)[&quot;href&quot;]) # https://example.com print(soup.select_one(&quot;h1.title&quot;).text) # 欢迎 9.1.6 辨析 (Misunderstanding) 误解 1：BeautifulSoup 能下载网页。 实际：它只解析，下载要用 requests。 误解 2：必须用 find_all，select 用不了。 实际：select 支持 CSS 语法，更灵活。 误解 3：只能解析 HTML。 实际：XML 也支持。 9.2 lxml 模块 9.2.1 核心 (What) lxml 是一个高性能的 XML/HTML 解析库，基于 C 语言 libxml2/libxslt 实现。 它比 BeautifulSoup 更快，并且支持 XPath 查询。 一句话总结：lxml 就是 “高速 HTML/XPath 工具”，适合大规模爬虫。 9.2.2 组成结构 (Dimension) 核心对象 lxml.etree：核心解析模块 Element：树节点 ElementTree：整个文档对象 查找方式 .xpath()：XPath 语法 .cssselect()：CSS 选择器（需安装 cssselect） 9.2.3 原理 (How it works) 基于 libxml2/libxslt (C 语言库)，所以速度快 把 HTML/XML 转成 树结构，支持 XPath/CSS 查询 与 BeautifulSoup 不同：它更偏底层，更快，但语法略复杂 9.2.4 应用 (Usage) 大规模爬虫，快速解析 HTML XML 配置文件解析 需要 XPath 定位元素的复杂页面 9.2.5 举例 (Example) from lxml import etree html = &quot;&quot;&quot; &lt;html&gt;&lt;body&gt; &lt;h1 class=&quot;title&quot;&gt;欢迎&lt;/h1&gt; &lt;a href=&quot;https://example.com&quot;&gt;链接&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; &quot;&quot;&quot; tree = etree.HTML(html) print(tree.xpath(&quot;//h1/text()&quot;)) # [&#39;欢迎&#39;] print(tree.xpath(&quot;//a/@href&quot;)) # [&#39;https://example.com&#39;] print(tree.xpath(&quot;//a/text()&quot;)) # [&#39;链接&#39;] 9.2.6 辨析 (Misunderstanding) 误解 1：lxml 只能解析 XML，不能解析 HTML。 实际：HTML/XML 都支持。 误解 2：XPath 很难学。 实际：XPath 类似文件路径，常用的几条规则很好记。 误解 3：BeautifulSoup 和 lxml 二选一。 实际：BeautifulSoup 可以用 lxml 作为底层解析器。 "],["C10.html", "Chapter 10 数据科学 10.1 scikit-learn 模块 10.2 PyTorch (torch) 模块 10.3 TensorFlow 模块 10.4 transformers 模块", " Chapter 10 数据科学 10.1 scikit-learn 模块 10.1.1 核心 (What) Scikit-learn 是 Python 的 通用机器学习库，提供了从数据预处理到建模、评估、调参的一整套工具。 一句话总结：scikit-learn 就是 “机器学习工具箱”，帮你快速完成分类、回归、聚类等任务。 10.1.2 组成结构 (Dimension) scikit-learn 的主要模块： 数据准备 datasets：内置示例数据集（鸢尾花、手写数字等） preprocessing：标准化、归一化、特征编码 模型训练 分类：LogisticRegression、RandomForestClassifier、SVC 回归：LinearRegression、Ridge、SVR 聚类：KMeans、DBSCAN 降维：PCA 模型评估 train_test_split：划分训练集/测试集 cross_val_score：交叉验证 metrics：准确率、F1 值、均方误差等 模型选择 GridSearchCV：网格搜索 RandomizedSearchCV：随机搜索 工具函数 pipeline：把预处理和模型串起来 joblib：保存/加载模型 10.1.3 原理 (How it works) 统一 API：所有模型都遵循 .fit()、.predict()、.score() 规范 基于 NumPy/Pandas：数据用数组或 DataFrame 表示 轻量化：只提供传统机器学习算法，不涉及深度学习（深度学习推荐 PyTorch/TensorFlow） 10.1.4 应用 (Usage) 分类：垃圾邮件识别、图像识别、情感分析 回归：房价预测、销量预测 聚类：用户分群、图像分割 降维：特征压缩、数据可视化（PCA） 数据预处理：标准化、特征选择 10.1.5 举例 (Examples) 10.1.5.1 分类：鸢尾花数据集 from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score # 加载数据 iris = load_iris() X, y = iris.data, iris.target # 划分训练集和测试集 X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # 训练模型 clf = RandomForestClassifier() clf.fit(X_train, y_train) # 预测 y_pred = clf.predict(X_test) print(&quot;准确率:&quot;, accuracy_score(y_test, y_pred)) 10.1.5.2 回归：房价预测（线性回归） from sklearn.linear_model import LinearRegression import numpy as np # 简单示例：面积 -&gt; 房价 X = np.array([[30], [50], [70], [90]]) # 特征 y = np.array([100, 200, 300, 400]) # 标签 model = LinearRegression() model.fit(X, y) print(&quot;预测 60 平米房价:&quot;, model.predict([[60]])) 10.1.5.3 聚类：KMeans from sklearn.cluster import KMeans import numpy as np X = np.array([[1,2],[1,4],[1,0], [10,2],[10,4],[10,0]]) kmeans = KMeans(n_clusters=2, random_state=0).fit(X) print(&quot;簇中心:&quot;, kmeans.cluster_centers_) print(&quot;分类结果:&quot;, kmeans.labels_) 10.1.6 辨析 (Misunderstanding) 误解 1：scikit-learn = 深度学习库。 实际：只做传统机器学习（决策树、SVM、逻辑回归等），深度学习用 TensorFlow / PyTorch。 误解 2：直接喂数据就能预测。 实际：通常需要 数据清洗 + 特征工程，否则效果差。 误解 3：准确率高就是模型好。 实际：要看场景，回归看 RMSE，分类要看 F1、AUC 等。 误解 4：只能用小数据。 实际：适合中小规模数据（几十万行），大数据需要 Spark MLlib、XGBoost。 ✅ 总结： Scikit-learn = Python 里的机器学习工具箱： 统一接口 → 学会一种模型，其他模型用法相同 功能齐全 → 分类、回归、聚类、降维、模型选择 适合入门机器学习、快速建模 10.2 PyTorch (torch) 模块 10.2.1 核心 (What) PyTorch 是 Facebook (Meta) 开发的 深度学习框架，主打 动态计算图、易上手、调试友好。 一句话总结：PyTorch 是 “科研利器”，更接近 Python 风格，写起来像普通代码。 10.2.2 组成结构 (Dimension) 核心对象：Tensor（多维数组，类似 NumPy） 计算图：自动构建（动态），反向传播自动计算梯度 模块 (nn.Module)：定义神经网络层（Linear, Conv2d 等） 优化器：SGD, Adam 等 数据加载：Dataset / DataLoader 10.2.3 原理 (How it works) 动态计算图：代码执行时构建计算图，更直观、灵活 自动求导：torch.autograd 追踪运算并计算梯度 GPU 加速：支持 CUDA（NVIDIA 显卡） 分布式训练：支持多 GPU / 多节点 10.2.4 应用 (Usage) 研究实验：新模型原型设计 自然语言处理（NLP）、计算机视觉（CV）、强化学习 大规模深度学习训练（PyTorch Lightning 等框架） 10.2.5 举例 (Example) import torch import torch.nn as nn import torch.optim as optim # 定义数据 x = torch.tensor([[1.0], [2.0], [3.0]]) y = torch.tensor([[2.0], [4.0], [6.0]]) # 定义模型 model = nn.Linear(1, 1) # 损失函数和优化器 criterion = nn.MSELoss() optimizer = optim.SGD(model.parameters(), lr=0.01) # 训练 for epoch in range(100): y_pred = model(x) loss = criterion(y_pred, y) optimizer.zero_grad() loss.backward() optimizer.step() print(&quot;预测结果:&quot;, model(torch.tensor([[4.0]])).item()) 10.2.6 辨析 (Misunderstanding) 误解 1：PyTorch 只能研究用，不能工业部署。 实际：已广泛应用于工业（TorchServe、ONNX）。 误解 2：Tensor 和 NumPy array 一样。 实际：Tensor 支持 GPU，加速更快。 误解 3：必须手写反向传播。 实际：autograd 会自动求导。 10.3 TensorFlow 模块 10.3.1 核心 (What) TensorFlow 是 Google 开发的 深度学习框架，主打 稳定性、可扩展、适合工业部署。 一句话总结：TensorFlow 是 “工业级生产工具”，生态完整，适合大规模应用。 10.3.2 组成结构 (Dimension) 核心对象：Tensor Keras API：高级接口，快速搭建神经网络 低层 API：灵活控制计算图 数据管道：tf.data 部署工具：TensorFlow Serving, TensorFlow Lite, TensorFlow.js 10.3.3 原理 (How it works) 静态计算图（TF1.x）：先定义图，再运行 动态图 (Eager Execution)（TF2.x 默认）：更接近 PyTorch 自动求导：tf.GradientTape 分布式训练：TPU/GPU 支持，适合云端大规模训练 10.3.4 应用 (Usage) 工业生产：Google 内部大规模 AI 系统 移动端 / 物联网：TensorFlow Lite Web 端：TensorFlow.js 云端训练：TensorFlow + TPU 10.3.5 举例 (Example) import tensorflow as tf # 定义数据 x = tf.constant([[1.0], [2.0], [3.0]]) y = tf.constant([[2.0], [4.0], [6.0]]) # 定义模型 model = tf.keras.Sequential([tf.keras.layers.Dense(1)]) # 编译 model.compile(optimizer=&quot;sgd&quot;, loss=&quot;mse&quot;) # 训练 model.fit(x, y, epochs=100, verbose=0) # 预测 print(&quot;预测结果:&quot;, model.predict([[4.0]])) 10.3.6 辨析 (Misunderstanding) 误解 1：TensorFlow 很难学。 实际：TF2.x + Keras 已经和 PyTorch 差不多简单。 误解 2：TensorFlow 只能写神经网络。 实际：还能做概率建模、强化学习等。 误解 3：TensorFlow 必须用静态图。 实际：2.x 默认动态图。 10.4 transformers 模块 10.4.1 核心 (What) transformers 是 Hugging Face 开发的 预训练模型库，集成了 BERT、GPT、T5、CLIP 等主流 Transformer 架构。 它让你只需几行代码，就能调用最前沿的 NLP、CV、多模态模型。 一句话总结：transformers 就是 “模型超市”，帮你快速下载和使用世界上最先进的深度学习模型。 10.4.2 组成结构 (Dimension) 主要模块： 模型类 AutoModel / AutoModelForSequenceClassification / AutoModelForCausalLM … 通用入口，自动加载合适的模型结构。 分词器 (Tokenizer) AutoTokenizer：把文本转成模型能理解的 token。 管道 (Pipeline) pipeline(\"task\", model=...)：一行解决常见任务。 任务：文本分类、情感分析、问答、翻译、文本生成、图像分类、语音识别。 Trainer API 简化模型微调流程：训练、评估、保存。 模型仓库 Hugging Face Hub：下载和分享预训练模型。 10.4.3 原理 (How it works) Transformer 架构：基于注意力机制 (Self-Attention)，并行处理序列数据，比 RNN 快。 预训练 + 微调：先在大规模语料上训练（如 BERT、GPT），再针对具体任务微调。 统一 API：通过 Auto 类自动匹配模型和分词器。 生态系统：和 datasets、accelerate、diffusers 等库无缝衔接。 10.4.4 应用 (Usage) 自然语言处理 (NLP)：文本分类、情感分析、命名实体识别、翻译、问答、文本生成。 计算机视觉 (CV)：图像分类、目标检测（ViT、DETR）。 语音处理 (ASR, TTS)：语音识别、语音合成。 多模态：CLIP（图文匹配）、BLIP（图像描述）、Whisper（语音转文字）。 10.4.5 举例 (Examples) 10.4.5.1 最简单：Pipeline 用法 from transformers import pipeline classifier = pipeline(&quot;sentiment-analysis&quot;) print(classifier(&quot;I love Python!&quot;)) # [{&#39;label&#39;: &#39;POSITIVE&#39;, &#39;score&#39;: 0.999}] 10.4.5.2 文本生成 (GPT) from transformers import pipeline generator = pipeline(&quot;text-generation&quot;, model=&quot;gpt2&quot;) print(generator(&quot;Once upon a time&quot;, max_length=30)) 10.4.5.3 问答 (BERT) from transformers import pipeline qa = pipeline(&quot;question-answering&quot;) result = qa(question=&quot;Who developed Python?&quot;, context=&quot;Python was created by Guido van Rossum.&quot;) print(result) # {&#39;score&#39;: 0.98, &#39;start&#39;: 18, &#39;end&#39;: 36, &#39;answer&#39;: &#39;Guido van Rossum&#39;} 10.4.5.4 手动加载模型和分词器 from transformers import AutoTokenizer, AutoModelForSequenceClassification tokenizer = AutoTokenizer.from_pretrained(&quot;distilbert-base-uncased&quot;) model = AutoModelForSequenceClassification.from_pretrained(&quot;distilbert-base-uncased&quot;) inputs = tokenizer(&quot;Hello world!&quot;, return_tensors=&quot;pt&quot;) outputs = model(**inputs) print(outputs.logits) 10.4.6 辨析 (Misunderstanding) 误解 1：transformers 只能做 NLP。 实际：支持 NLP + CV + 语音 + 多模态。 误解 2：一定要自己训练模型。 实际：大多数任务直接用预训练模型就能得到好效果。 误解 3：transformers 太重，不适合小白。 实际：pipeline 一行代码就能用，入门非常友好。 误解 4：和 PyTorch/TensorFlow 重复。 实际：transformers 依赖它们作为后端，主要提供模型封装和预训练权重。 "],["C11.html", "Chapter 11 工具 11.1 pytest 模块 11.2 virtualenv 11.3 conda 11.4 poetry 11.5 black 11.6 flake8 11.7 isort", " Chapter 11 工具 11.1 pytest 模块 11.1.1 核心 (What) pytest 是 Python 最流行的 单元测试框架，用于编写和运行测试代码。 相比 Python 内置的 unittest，pytest 更 简洁、强大、可扩展。 一句话总结：pytest 就是 “Python 测试利器”，让你写测试像写普通函数一样简单。 11.1.2 组成结构 (Dimension) pytest 的主要功能模块： 测试函数 直接写 def test_xxx(): 就是一个测试 不需要继承类、不需要写复杂的结构 断言 (assert) 使用 Python 内置的 assert，pytest 自动增强错误提示 Fixture（测试夹具） 可复用的测试准备/清理代码 用 @pytest.fixture 标记 参数化 @pytest.mark.parametrize 可用一组输入跑多个测试 插件系统 pytest-django、pytest-cov 等扩展功能 命令行工具 pytest -v：详细模式 pytest -k \"keyword\"：运行包含关键字的测试 pytest --maxfail=1 --disable-warnings：出错即停 11.1.3 原理 (How it works) pytest 会扫描项目里的 test 文件（以 test_ 开头） 自动发现测试函数/类 → 执行 → 收集结果 断言失败时，pytest 会打印详细的变量对比，而不是简单的 True/False 通过 fixture 提供依赖注入，方便管理测试上下文 11.1.4 应用 (Usage) 单元测试：测试单个函数是否正确 集成测试：测试多个模块是否能协同工作 回归测试：防止修改代码后旧功能被破坏 持续集成 (CI/CD)：结合 GitHub Actions、GitLab CI 自动运行测试 11.1.5 举例 (Examples) 11.1.5.1 基本测试 # test_math.py def add(x, y): return x + y def test_add(): assert add(2, 3) == 5 运行： pytest -v 输出： test_math.py::test_add PASSED 11.1.5.2 Fixture 用法 import pytest @pytest.fixture def sample_data(): return {&quot;a&quot;: 1, &quot;b&quot;: 2} def test_dict(sample_data): assert sample_data[&quot;a&quot;] == 1 11.1.5.3 参数化测试 import pytest @pytest.mark.parametrize(&quot;x, y, expected&quot;, [ (2, 3, 5), (1, 5, 6), (0, 0, 0) ]) def test_add(x, y, expected): assert x + y == expected 11.1.5.4 异常测试 import pytest def divide(a, b): return a / b def test_divide_by_zero(): with pytest.raises(ZeroDivisionError): divide(1, 0) 11.1.6 辨析 (Misunderstanding) 误解 1：pytest 只能替代 unittest。 实际：pytest 兼容 unittest 和 nose 的测试用例，可以无缝迁移。 误解 2：写测试很麻烦。 实际：pytest 让测试代码和普通函数差不多简单。 误解 3：pytest 只能测小项目。 实际：大型项目常配合 CI/CD、覆盖率统计、mock 工具使用。 误解 4：assert 太简单，不够专业。 实际：pytest 会增强 assert，显示变量对比，非常直观。 11.2 virtualenv 11.2.1 核心 (What) virtualenv 是 Python 最早期、最经典的 虚拟环境工具。 作用是：为每个项目创建一个 独立的 Python 环境（解释器 + 包），避免多个项目之间的依赖冲突。 11.2.2 组成结构 (Dimension) 创建环境：virtualenv venv 激活环境：source venv/bin/activate (Linux/macOS)，venv\\Scripts\\activate (Windows) 安装依赖：pip install 包名 11.2.3 原理 (How it works) 拷贝一份 Python 解释器到指定目录 创建一个隔离的 site-packages 目录 激活时修改 PATH，让项目用独立环境 11.2.4 应用 (Usage) 小型项目，依赖不复杂 想快速上手虚拟环境 11.2.5 举例 (Example) pip install virtualenv virtualenv venv source venv/bin/activate pip install requests 11.2.6 辨析 (Misunderstanding) ❌ 误解 1：virtualenv 自带包管理。 实际：它只隔离环境，依赖管理还要靠 pip + requirements.txt。 ❌ 误解 2：virtualenv 和 venv 一样。 实际：venv 是 Python3 自带的轻量版 virtualenv。 11.3 conda 11.3.1 核心 (What) conda 是 Anaconda 生态里的 包管理 + 环境管理工具。 它不仅能管理 Python 包，还能管理 C 库、系统依赖，适合科学计算。 11.3.2 组成结构 (Dimension) 创建环境：conda create -n myenv python=3.10 激活环境：conda activate myenv 安装依赖：conda install numpy pandas 环境导出：conda env export &gt; env.yml 11.3.3 原理 (How it works) conda 管理的是 二进制包（含依赖库） 不依赖 pip，直接安装编译好的包 特别适合需要 C/C++ 库的科学计算场景 11.3.4 应用 (Usage) 数据科学 / 机器学习（numpy, pandas, tensorflow, pytorch） 跨平台部署，特别是在 Windows 下更友好 11.3.5 举例 (Example) conda create -n ds python=3.9 conda activate ds conda install numpy pandas scikit-learn 11.3.6 辨析 (Misunderstanding) ❌ 误解 1：conda 只能管理 Python 包。 实际：它能管理 C 库、R 包、系统依赖。 ❌ 误解 2：conda 和 pip 冲突。 实际：它们可以配合使用，但建议优先用 conda 安装大包。 11.4 poetry 11.4.1 核心 (What) poetry 是新一代 Python 依赖管理 + 打包工具。 它不仅能创建虚拟环境，还能 自动解析依赖版本、生成 lock 文件、发布到 PyPI。 一句话总结：poetry = pip + virtualenv + setuptools 的现代替代品。 11.4.2 组成结构 (Dimension) 配置文件：pyproject.toml（声明依赖和元信息） 虚拟环境：poetry install 会自动创建和管理 锁文件：poetry.lock 保证依赖版本一致 发布工具：poetry publish 11.4.3 原理 (How it works) 基于 PEP 518 的标准（pyproject.toml） 自动解析依赖冲突，生成锁定版本 内置虚拟环境管理，不依赖手动 venv 11.4.4 应用 (Usage) Python 应用和库的开发（尤其是需要发布到 PyPI） 需要严格依赖管理的团队项目 11.4.5 举例 (Example) pip install poetry poetry init poetry add requests poetry install poetry run python main.py 11.4.6 辨析 (Misunderstanding) ❌ 误解 1：poetry = pip。 实际：poetry 是完整的项目管理工具，pip 只是安装包。 ❌ 误解 2：poetry 必须手动建虚拟环境。 实际：它会自动管理虚拟环境。 ❌ 误解 3：poetry 只适合开源项目。 实际：团队开发和商业项目也很适合。 11.5 black 11.5.1 核心 (What) black 是一个 自动代码格式化工具，号称 The Uncompromising Code Formatter。 它的核心思想是：不用讨论风格问题，直接全自动统一格式。 11.5.2 组成结构 (Dimension) 命令行工具：black file.py 配置文件：pyproject.toml（可以设置行宽等少量参数） 编辑器插件：VSCode、PyCharm 都支持 11.5.3 原理 (How it works) 解析 Python 代码 → 转换为语法树 → 重新输出格式化后的代码 代码风格是固定的，用户几乎不能定制（避免团队争论） 11.5.4 应用 (Usage) 项目中统一代码风格 CI/CD 自动化检查 + 格式化 团队协作时避免 “格式吵架” 11.5.5 举例 (Example) 原始代码： def add(a,b): return a+b 执行： black file.py 输出： def add(a, b): return a + b 11.5.6 辨析 (Misunderstanding) ❌ 误解 1：black 会改动逻辑。 实际：它只改格式，不动逻辑。 ❌ 误解 2：black 可高度定制。 实际：几乎不能定制，只能调整少数选项（如行宽）。 11.6 flake8 11.6.1 核心 (What) flake8 是一个 代码检查工具 (linter)，用来发现潜在的 语法错误、风格问题、不规范写法。 一句话总结：flake8 = 代码警察，帮你发现问题，但不自动改。 11.6.2 组成结构 (Dimension) 命令行工具：flake8 file.py 配置文件：.flake8 或 setup.cfg 插件生态：flake8-docstrings、flake8-import-order 等 11.6.3 原理 (How it works) 基于 PyFlakes（语法错误检查）+ pycodestyle（PEP8 风格检查）+ McCabe（复杂度检查） 把代码扫描一遍，输出错误编号和提示 11.6.4 应用 (Usage) 检查变量未使用、未导入 提醒缩进、命名、空格等不规范 发现循环/函数过于复杂 11.6.5 举例 (Example) 代码： x=1 print(y) 执行： flake8 file.py 输出： file.py:1:1: E225 missing whitespace around operator file.py:2:7: F821 undefined name &#39;y&#39; 11.6.6 辨析 (Misunderstanding) ❌ 误解 1：flake8 会自动修复错误。 实际：它只报错，不修改。 ❌ 误解 2：flake8 只检查语法。 实际：它还能检查复杂度和风格。 11.7 isort 11.7.1 核心 (What) isort 专门用于 自动排序 import 语句，让导入更整洁。 11.7.2 组成结构 (Dimension) 命令行工具：isort file.py 配置文件：pyproject.toml、.isort.cfg 可配置分组：标准库 / 第三方库 / 本地模块 11.7.3 原理 (How it works) 读取代码 → 解析 import → 按规则分组并排序 分组规则：标准库在前，第三方在中，本地在后 11.7.4 应用 (Usage) 保持 import 语句一致 大型项目更容易读代码 与 black 配合，自动保持格式 11.7.5 举例 (Example) 原始代码： import pandas import os import numpy 执行： isort file.py 输出： import os import numpy import pandas 11.7.6 辨析 (Misunderstanding) ❌ 误解 1：isort 只是排序字母表。 实际：它按 分组规则（标准库 / 第三方 / 本地）来整理。 ❌ 误解 2：isort 会影响逻辑。 实际：只改变 import 顺序，不改运行逻辑。 "],["C12.html", "Chapter 12 LLM 12.1 openai 模块 12.2 faiss 模块 12.3 peft 模块", " Chapter 12 LLM 12.1 openai 模块 12.1.1 核心 (What) openai 是 OpenAI 官方的 Python SDK，用于调用 OpenAI 提供的大模型和服务。 通过它，你可以很方便地使用 ChatGPT、GPT-4/5、DALL·E、Whisper 等 API。 一句话总结：openai 就是 通往 OpenAI 模型的钥匙，帮你用几行代码调用最先进的 AI。 12.1.2 组成结构 (Dimension) 主要功能模块： 聊天与文本生成 chat.completions.create：调用 GPT 系列生成对话或文本 嵌入向量 (Embeddings) embeddings.create：将文本转成向量，用于语义搜索、推荐系统 图片 (Image) images.generate：生成图片（DALL·E） images.edit / images.variations：修改或扩展图片 语音 (Audio) audio.transcriptions.create：语音转文字（Whisper） audio.speech.create：文字转语音 批处理与文件管理 batches：批量处理请求 files：上传数据文件，用于微调/批处理 微调 (Fine-tuning) fine_tuning.jobs.create：训练专属模型 12.1.3 原理 (How it works) API 调用：通过 HTTPS 请求访问 OpenAI 的云端模型 SDK 封装：openai 库把复杂的 API 调用封装成 Python 方法 鉴权：必须提供 OPENAI_API_KEY 环境变量 计费：按调用的 token 数量、图片大小、音频时长收费 12.1.4 应用 (Usage) 智能对话：客服机器人、智能助理 文本生成：写文章、代码补全、摘要 知识检索：结合 embeddings 构建 RAG 系统 多模态应用：生成图片、音频，支持 AI 创作 行业应用：教育、金融、医疗、游戏、办公自动化 12.1.5 举例 (Examples) 12.1.5.1 聊天 from openai import OpenAI client = OpenAI() response = client.chat.completions.create( model=&quot;gpt-4o-mini&quot;, messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;写一个三行小诗&quot;}] ) print(response.choices[0].message[&quot;content&quot;]) 12.1.5.2 文本嵌入 embedding = client.embeddings.create( model=&quot;text-embedding-3-small&quot;, input=&quot;机器学习改变世界&quot; ) print(embedding.data[0].embedding[:5]) # 向量前 5 个值 12.1.5.3 生成图片 image = client.images.generate( model=&quot;gpt-image-1&quot;, prompt=&quot;一只戴眼镜的猫在编程&quot; ) print(image.data[0].url) 12.1.5.4 语音转文字 audio_file = open(&quot;speech.mp3&quot;, &quot;rb&quot;) transcript = client.audio.transcriptions.create( model=&quot;whisper-1&quot;, file=audio_file ) print(transcript.text) 12.1.6 辨析 (Misunderstanding) 误解 1：安装 openai 就能离线跑 GPT。 实际：openai 只是客户端，核心模型在云端，需要 API Key 和网络。 误解 2：openai 只能做聊天。 实际：还能做图片、语音、嵌入、微调。 误解 3：openai 免费无限用。 实际：是付费 API，按使用量计费。 误解 4：openai = ChatGPT 网页版。 实际：ChatGPT 网页版只是这个 API 的一个封装，openai SDK 更灵活。 12.2 faiss 模块 12.2.1 核心 (What) FAISS（Facebook AI Similarity Search）是一个 高效相似度搜索库，主要用于 向量检索。 它能在海量向量数据（上百万、上亿）中快速找到最相似的向量（最近邻搜索）。 一句话总结：FAISS 就是 “找相似东西的超级搜索引擎”，特别适合 AI 场景（文本、图片、音频的向量检索）。 12.2.2 组成结构 (Dimension) 主要模块： Index（索引结构） IndexFlatL2：暴力搜索（精确最近邻） IndexIVF：倒排文件索引（近似搜索） IndexPQ：乘积量化（压缩存储） IndexHNSW：基于图的近似搜索 向量操作 add()：添加向量到索引 search()：查询最近邻 remove_ids()：删除向量 GPU 加速 支持 faiss-gpu，能在 GPU 上做大规模检索 12.2.3 原理 (How it works) 向量空间搜索：把数据（文本/图像/语音）转成向量，再比较相似度（余弦相似度、欧氏距离）。 暴力搜索：逐个比对，适合小规模数据。 近似搜索：用倒排索引 / 量化 / 图搜索，速度快，稍微牺牲精度。 压缩存储：支持对高维向量压缩，节省内存。 12.2.4 应用 (Usage) 文本搜索（语义检索）：结合 transformers 的 embeddings 图像检索：相似图片搜索 推荐系统：找相似用户 / 物品 RAG（检索增强生成）：大模型问答前先从向量库里检索知识 12.2.5 举例 (Examples) 12.2.5.1 基本用法：暴力搜索 import numpy as np import faiss # 构造向量数据库 (1000个向量，维度=128) d = 128 nb = 1000 np.random.seed(0) xb = np.random.random((nb, d)).astype(&quot;float32&quot;) # 构造索引 index = faiss.IndexFlatL2(d) # L2 距离 index.add(xb) # 添加向量 # 查询向量 xq = np.random.random((5, d)).astype(&quot;float32&quot;) D, I = index.search(xq, 3) # 找每个查询向量的 3 个最近邻 print(&quot;距离:&quot;, D) print(&quot;索引:&quot;, I) 12.2.5.2 倒排索引（更快） nlist = 100 # 聚类中心数量 quantizer = faiss.IndexFlatL2(d) index = faiss.IndexIVFFlat(quantizer, d, nlist) index.train(xb) # 先训练 index.add(xb) D, I = index.search(xq, 3) 12.2.5.3 GPU 加速 res = faiss.StandardGpuResources() gpu_index = faiss.index_cpu_to_gpu(res, 0, index) 12.2.6 辨析 (Misunderstanding) 误解 1：faiss 只能用在图像检索。 实际：任何能转成向量的数据（文本、音频、用户行为）都能用。 误解 2：faiss 结果总是精确的。 实际：近似搜索牺牲一点精度换速度。 误解 3：faiss = 数据库。 实际：它只是 向量搜索引擎，没有事务、权限等数据库功能。 误解 4：faiss 很难用。 实际：基本用法和 add() / search() 类似字典。 12.3 peft 模块 12.3.1 核心 (What) peft 是 Hugging Face 推出的 参数高效微调库，用来在不修改全部参数的情况下，快速微调大语言模型 (LLM)。 它的核心目标：少量参数 → 保持模型效果 → 降低算力和存储成本。 一句话总结：peft = “低成本微调大模型的神器”。 12.3.2 组成结构 (Dimension) 主要方法： LoRA (Low-Rank Adaptation) 在权重矩阵上插入低秩分解，只更新小部分参数 Prefix Tuning / Prompt Tuning 在输入前面加一段可训练的向量，不动原始模型参数 P-Tuning v2 类似 Prompt Tuning，但更高效、适合大模型 Adapters 在模型层之间插入小模块，只训练这些模块 配置与管理 LoraConfig, PrefixTuningConfig … get_peft_model() 包装已有模型 12.3.3 原理 (How it works) 普通微调：更新模型所有参数（几亿~千亿），代价极高 PEFT：只在模型里“加小组件”或“加可训练向量”，冻结大部分参数 好处： 显存占用低（几百 MB 就能调大模型） 训练更快 容易切换任务（换 LoRA 权重即可） 12.3.4 应用 (Usage) 文本分类 / 情感分析（在 GPT/BERT 上加 LoRA） 聊天机器人（在 LLaMA / Qwen / Mistral 等模型上做对话微调） 翻译 / 摘要 领域适配（比如把通用模型调成“法律顾问模型”“医疗助手模型”） 12.3.5 举例 (Example) 12.3.5.1 给 BERT 加 LoRA from transformers import AutoModelForSequenceClassification, AutoTokenizer from peft import LoraConfig, get_peft_model # 加载预训练模型 model_name = &quot;bert-base-uncased&quot; tokenizer = AutoTokenizer.from_pretrained(model_name) model = AutoModelForSequenceClassification.from_pretrained(model_name, num_labels=2) # 配置 LoRA config = LoraConfig( task_type=&quot;SEQ_CLS&quot;, r=8, # 降秩维度 lora_alpha=32, # 缩放因子 lora_dropout=0.1 ) # 包装模型 peft_model = get_peft_model(model, config) # 查看可训练参数 peft_model.print_trainable_parameters() 输出示例： trainable params: 147,456 || all params: 110,104,066 || trainable%: 0.13 👉 只训练了 0.13% 的参数！ 12.3.6 辨析 (Misunderstanding) 误解 1：PEFT = 微调。 实际：PEFT 不是全量微调，而是 冻结大部分参数 + 调小模块。 误解 2：LoRA 只能用在 Transformer。 实际：LoRA 思路通用，CNN / RNN 也能用。 误解 3：PEFT 牺牲效果。 实际：很多任务上，PEFT 接近甚至等于全量微调效果。 误解 4：PEFT 只能单任务。 实际：LoRA 权重可以“热插拔”，很适合多任务切换。 "],["GUI.html", "Chapter 13 GUI 13.1 tkinter 模块 13.2 PyQt / PySide 模块 13.3 wxPython 模块 13.4 wxPython 13.5 Kivy 13.6 BeeWare / Toga", " Chapter 13 GUI 13.1 tkinter 模块 13.1.1 核心 tkinter 是 Python 自带的图形界面库，封装了 Tcl/Tk 库。 它可以让你用 Python 代码创建窗口、按钮、文本框、标签等常见的 GUI 控件。 一句话总结：tkinter 是 Python 内置的轻量级桌面应用开发工具，零安装，开箱即用。 13.1.2 组成结构 1 窗口管理 Tk 主窗口 Toplevel 额外窗口 2 控件 Label 标签 Button 按钮 Entry 文本输入框 Text 多行文本框 Checkbutton 复选框 Radiobutton 单选按钮 Listbox 列表框 Canvas 画布 Frame 容器 3 布局管理 pack 按顺序摆放 grid 网格布局 place 指定位置 4 事件绑定 bind 方法可绑定键盘 鼠标事件 command 属性可绑定函数 13.1.3 原理 tkinter 是对 Tcl/Tk GUI 库的封装 创建 Tk 实例后会进入主循环 mainloop 持续等待和响应用户操作 控件对象通过方法调用更新界面，不需要手动刷新 13.1.4 应用 简单桌面小工具 学习 GUI 编程入门 原型界面开发 内部工具（文件批量处理器、数据录入工具） 13.1.5 举例 最简单的窗口 import tkinter as tk root = tk.Tk() root.title(&quot;我的第一个窗口&quot;) label = tk.Label(root, text=&quot;你好 tkinter&quot;) label.pack() root.mainloop() 带按钮交互 import tkinter as tk def say_hello(): label.config(text=&quot;按钮被点击了&quot;) root = tk.Tk() root.title(&quot;按钮示例&quot;) label = tk.Label(root, text=&quot;初始文本&quot;) label.pack() button = tk.Button(root, text=&quot;点我&quot;, command=say_hello) button.pack() root.mainloop() 布局示例 import tkinter as tk root = tk.Tk() for i in range(3): for j in range(3): tk.Label(root, text=f&quot;{i},{j}&quot;, borderwidth=1, relief=&quot;solid&quot;).grid(row=i, column=j, padx=5, pady=5) root.mainloop() 13.1.6 辨析 1 误解 tkinter 很落后 实际 虽然界面简陋 但足以胜任小工具开发 并且零依赖 2 误解 tkinter 不能做复杂界面 实际 tkinter 提供 canvas 可绘制自定义组件 但复杂界面更推荐 PyQt 或 wxPython 3 误解 tkinter 需要单独安装 实际 Python 自带 tkinter 大多数环境可直接使用 13.1.7 总结 tkinter 是最简单的 Python 图形界面工具 优点 零安装 易学 快速原型 缺点 风格老旧 功能有限 不适合大型应用 适合 入门学习 小型工具 快速试验 13.2 PyQt / PySide 模块 13.2.1 核心 PyQt 和 PySide 都是基于 Qt 框架的 Python 绑定。Qt 是一个强大的跨平台 C++ GUI 框架，可以开发功能完整、外观现代的桌面应用。 区别在于： PyQt 由 Riverbank 公司维护，GPL 或商业授权 PySide 由 Qt 官方（The Qt Company）维护，LGPL 授权，更自由 一句话总结：PyQt 和 PySide 都能让 Python 拥有专业级的桌面应用开发能力，界面和功能可以媲美原生应用。 13.2.2 组成结构 1 窗口与控件 QWidget 基础窗口 QMainWindow 主窗口 QPushButton 按钮 QLabel 标签 QLineEdit 单行输入 QTextEdit 多行文本 QTableWidget 表格 QTreeView 树形控件 2 布局管理 QVBoxLayout 垂直布局 QHBoxLayout 水平布局 QGridLayout 网格布局 QFormLayout 表单布局 3 信号与槽 信号 signal 类似事件 槽 slot 类似回调函数 控件通过 signal-slot 机制完成交互 4 其他功能模块 QPainter 绘图 QTimer 定时器 QFileDialog 文件选择对话框 QThread 多线程支持 13.2.3 原理 Qt 库是用 C++ 实现的，PyQt 和 PySide 提供 Python 接口 运行时 Python 调用 Qt 库，由 Qt 渲染窗口和控件 核心机制是信号与槽（事件驱动），控件之间通过消息传递实现交互 程序主循环由 app.exec_() 驱动 13.2.4 应用 专业桌面应用（IDE、绘图工具、播放器） 企业内部工具（数据管理、信息系统客户端） 跨平台应用（Windows、macOS、Linux） 可视化界面（结合 matplotlib、OpenGL） 13.2.5 举例 最简单的窗口 import sys from PyQt5.QtWidgets import QApplication, QLabel app = QApplication(sys.argv) label = QLabel(&quot;你好，PyQt&quot;) label.show() app.exec_() 带按钮交互 import sys from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QVBoxLayout, QLabel def on_click(): label.setText(&quot;按钮被点击了&quot;) app = QApplication(sys.argv) window = QWidget() window.setWindowTitle(&quot;PyQt 示例&quot;) label = QLabel(&quot;初始文本&quot;) button = QPushButton(&quot;点我&quot;) button.clicked.connect(on_click) layout = QVBoxLayout() layout.addWidget(label) layout.addWidget(button) window.setLayout(layout) window.show() app.exec_() 表格控件 from PyQt5.QtWidgets import QApplication, QTableWidget, QTableWidgetItem import sys app = QApplication(sys.argv) table = QTableWidget(3, 2) table.setHorizontalHeaderLabels([&quot;姓名&quot;, &quot;年龄&quot;]) table.setItem(0, 0, QTableWidgetItem(&quot;张三&quot;)) table.setItem(0, 1, QTableWidgetItem(&quot;25&quot;)) table.show() app.exec_() 13.2.6 辨析 1 常见误解是 PyQt 和 PySide 有本质不同 实际 二者 API 基本一致，大多数代码可以互换，主要差异在授权协议 2 常见误解是 PyQt 太复杂 实际 PyQt 提供 Qt Designer 可视化设计工具，可以拖拽生成界面 3 常见误解是 Python 做桌面应用不如 C++ 实际 如果性能要求不是极限，Python + Qt 足以满足大部分桌面开发需求 4 常见误解是 PyQt 不能跨平台 实际 PyQt 和 PySide 完全跨平台，Qt 在各大系统上表现一致 13.2.7 总结 PyQt 和 PySide 都基于 Qt 框架，功能强大，适合开发复杂桌面应用 PyQt 商业授权更严格，PySide 更自由 推荐入门学习 PySide，团队开发或商用时更容易避免授权问题 13.3 wxPython 模块 13.3.1 核心 wxPython 是一个基于 C++ GUI 框架 wxWidgets 的 Python 封装库。 它的特点是：在不同系统上调用原生控件，所以程序在 Windows、macOS、Linux 上看起来更贴近系统风格。 一句话总结：wxPython 是一个跨平台 GUI 框架，界面效果更接近系统原生。 13.3.2 组成结构 1 应用与窗口 wx.App 应用对象 wx.Frame 主窗口 wx.Panel 面板 容纳控件 wx.Dialog 对话框 2 控件 wx.Button 按钮 wx.StaticText 静态文本 wx.TextCtrl 文本输入框 wx.CheckBox 复选框 wx.RadioButton 单选按钮 wx.ListBox 列表框 wx.Grid 表格控件 3 布局管理 wx.BoxSizer 水平 垂直布局 wx.GridSizer 网格布局 wx.FlexGridSizer 可变网格 4 事件系统 通过 Bind 方法绑定事件 事件对象如 wx.EVT_BUTTON wx.EVT_TEXT 13.3.3 原理 wxPython 基于 wxWidgets 运行 每个平台调用的是原生控件 所以界面风格贴合系统 主循环由 app.MainLoop 驱动，事件通过回调函数处理 13.3.4 应用 桌面工具开发 跨平台软件（Windows、Linux、macOS） 内部信息系统客户端 原型界面开发 13.3.5 举例 最简单的窗口 import wx app = wx.App() frame = wx.Frame(None, title=&quot;你好，wxPython&quot;, size=(300, 200)) frame.Show() app.MainLoop() 带按钮交互 import wx class MyFrame(wx.Frame): def __init__(self): super().__init__(None, title=&quot;按钮示例&quot;) panel = wx.Panel(self) self.text = wx.StaticText(panel, label=&quot;初始文本&quot;, pos=(20, 20)) button = wx.Button(panel, label=&quot;点我&quot;, pos=(20, 50)) button.Bind(wx.EVT_BUTTON, self.on_click) def on_click(self, event): self.text.SetLabel(&quot;按钮被点击了&quot;) app = wx.App() frame = MyFrame() frame.Show() app.MainLoop() 布局示例 import wx app = wx.App() frame = wx.Frame(None, title=&quot;布局示例&quot;) panel = wx.Panel(frame) sizer = wx.BoxSizer(wx.VERTICAL) sizer.Add(wx.Button(panel, label=&quot;按钮1&quot;), 0, wx.ALL, 5) sizer.Add(wx.Button(panel, label=&quot;按钮2&quot;), 0, wx.ALL, 5) panel.SetSizer(sizer) frame.Show() app.MainLoop() 13.3.6 辨析 1 误解 wxPython 和 PyQt 一样 实际 wxPython 更轻量 界面原生风格更好 但生态不如 Qt 完整 2 误解 wxPython 界面老旧 实际 wxPython 使用系统控件 看起来更贴近操作系统本身 3 误解 wxPython 不支持复杂应用 实际 wxPython 提供丰富控件 包括表格 树形结构 富文本 但社区资料相对少 13.3.7 总结 wxPython 是跨平台 GUI 框架，界面原生友好 优点 跨平台 原生风格 上手比 PyQt 简单 缺点 社区规模较小 教程不如 PyQt 丰富 适合 想要轻量跨平台原生体验的桌面应用 13.4 wxPython 13.4.1 核心 wxPython 是基于 C++ 框架 wxWidgets 的 Python 封装。 它最大的特点是：在不同系统上调用系统自带的原生控件，所以界面风格会和 Windows、macOS、Linux 的默认应用保持一致。 一句话总结：wxPython 是一个跨平台、原生风格的 Python 图形界面开发框架。 13.4.2 组成结构 1 应用与窗口 wx.App 应用入口 wx.Frame 主窗口 wx.Panel 面板 用来放控件 wx.Dialog 对话框 2 常见控件 wx.Button 按钮 wx.StaticText 标签 wx.TextCtrl 文本输入框 wx.CheckBox 复选框 wx.RadioButton 单选按钮 wx.ListBox 列表框 wx.Grid 表格 3 布局管理 wx.BoxSizer 水平或垂直布局 wx.GridSizer 网格布局 wx.FlexGridSizer 可变网格 4 事件系统 所有交互通过 Bind 方法绑定 常用事件 wx.EVT_BUTTON wx.EVT_TEXT wx.EVT_CHECKBOX 13.4.3 原理 wxPython 调用 wxWidgets，而 wxWidgets 使用系统的原生控件。 应用先创建 wx.App 对象，再进入 MainLoop 消息循环。 用户操作（点击、输入）触发事件，事件回调函数处理逻辑。 13.4.4 应用 跨平台桌面应用（内部小工具、管理软件） 数据处理和可视化界面 需要原生外观的桌面客户端 快速原型界面开发 13.4.5 举例 最简单窗口 import wx app = wx.App() frame = wx.Frame(None, title=&quot;你好，wxPython&quot;, size=(300, 200)) frame.Show() app.MainLoop() 按钮交互 import wx class MyFrame(wx.Frame): def __init__(self): super().__init__(None, title=&quot;按钮示例&quot;) panel = wx.Panel(self) self.label = wx.StaticText(panel, label=&quot;初始文本&quot;, pos=(20, 20)) button = wx.Button(panel, label=&quot;点我&quot;, pos=(20, 60)) button.Bind(wx.EVT_BUTTON, self.on_click) def on_click(self, event): self.label.SetLabel(&quot;按钮被点击了&quot;) app = wx.App() frame = MyFrame() frame.Show() app.MainLoop() 布局管理 import wx app = wx.App() frame = wx.Frame(None, title=&quot;布局示例&quot;) panel = wx.Panel(frame) sizer = wx.BoxSizer(wx.VERTICAL) sizer.Add(wx.Button(panel, label=&quot;按钮1&quot;), 0, wx.ALL, 5) sizer.Add(wx.Button(panel, label=&quot;按钮2&quot;), 0, wx.ALL, 5) panel.SetSizer(sizer) frame.Show() app.MainLoop() 13.4.6 辨析 1 误解 wxPython 落后 实际 wxPython 使用原生控件，界面和系统一致，不会显得老旧。 2 误解 wxPython 功能不如 PyQt 实际 wxPython 也有丰富的控件，包括表格、树、富文本，只是生态和资料不如 PyQt 丰富。 3 误解 wxPython 只能做简单工具 实际 wxPython 能做完整的桌面应用，只是大型项目更多使用 PyQt。 13.4.7 总结 wxPython 优点 跨平台 原生外观 上手简单 缺点 文档和社区规模较小 教程不如 PyQt 丰富 适合需要原生外观的桌面应用 或中小型跨平台项目 13.5 Kivy 13.5.1 核心 Kivy 是一个跨平台的图形界面开发框架，支持桌面、Android、iOS 等平台。 它最大的特点是： 使用 OpenGL 加速，界面流畅 内置触摸、手势、多点触控支持 适合开发现代化、跨平台的应用 一句话总结：Kivy 是一个面向桌面和移动端的跨平台 Python GUI 框架。 13.5.2 组成结构 1 应用程序入口 App 所有应用继承自 App 类 build 方法返回根控件 2 常见控件 Label 标签 Button 按钮 TextInput 文本输入框 CheckBox 复选框 Slider 滑动条 Switch 开关 Layout 布局容器 3 布局管理 BoxLayout 水平或垂直排列 GridLayout 网格布局 StackLayout 堆叠布局 AnchorLayout 定点布局 4 KV 语言 Kivy 提供专门的 kv 文件 描述界面，相当于 HTML+CSS 的作用 将界面布局和逻辑分离 13.5.3 原理 Kivy 使用 OpenGL ES 渲染界面，因此在桌面和移动端都有流畅的动画效果 控件事件通过回调函数绑定，比如 on_press on_text KV 语言可以定义布局、属性和事件，简化界面开发 13.5.4 应用 移动端跨平台应用（Android、iOS） 桌面应用（Windows、macOS、Linux） 教学演示和原型开发 需要动画、触摸、手势交互的应用 13.5.5 举例 最简单窗口 from kivy.app import App from kivy.uix.label import Label class MyApp(App): def build(self): return Label(text=&quot;你好，Kivy&quot;) MyApp().run() 按钮交互 from kivy.app import App from kivy.uix.button import Button class MyApp(App): def build(self): return Button(text=&quot;点我&quot;, on_press=self.say_hello) def say_hello(self, instance): instance.text = &quot;按钮被点击了&quot; MyApp().run() 使用布局 from kivy.app import App from kivy.uix.boxlayout import BoxLayout from kivy.uix.button import Button class MyApp(App): def build(self): layout = BoxLayout(orientation=&quot;vertical&quot;) layout.add_widget(Button(text=&quot;按钮1&quot;)) layout.add_widget(Button(text=&quot;按钮2&quot;)) return layout MyApp().run() KV 文件示例 main.py from kivy.app import App from kivy.uix.boxlayout import BoxLayout class MyLayout(BoxLayout): pass class MyApp(App): def build(self): return MyLayout() MyApp().run() my.kv &lt;MyLayout&gt;: orientation: &quot;vertical&quot; Button: text: &quot;按钮1&quot; Button: text: &quot;按钮2&quot; 13.5.6 辨析 1 误解 Kivy 只能做手机应用 实际 Kivy 同样支持桌面应用，只是移动端优势更明显 2 误解 Kivy 不够专业 实际 Kivy 提供 OpenGL 加速和手势支持，能做出流畅的现代化界面 3 误解 Kivy 学习成本高 实际 Kivy 上手很快，尤其是 KV 语言让界面代码更简洁 13.5.7 总结 Kivy 优点 跨平台 支持触摸和动画 适合移动端 缺点 打包和发布相对复杂 桌面应用外观不如 PyQt 原生 适合 跨平台移动端应用 原型工具 教学项目 13.6 BeeWare / Toga 13.6.1 核心 BeeWare 是一个跨平台应用开发工具集，其中 Toga 是它的 GUI 库。 它的特点是： 用 Python 写一次代码，可以运行在 Windows、macOS、Linux、Android、iOS，甚至 Web。 Toga 提供统一的 API，底层调用各个平台的原生控件。 BeeWare 还包括 Briefcase（打包工具）等，帮助你生成安装包或移动端 App。 一句话总结：BeeWare/Toga 让 Python 能像 JavaScript 的 Electron 或 Flutter 一样，跨平台开发桌面和移动应用。 13.6.2 组成结构 1 Toga 控件 Label 标签 Button 按钮 TextInput 文本框 Switch 开关 Table 表格 Tree 树控件 2 布局管理 Box 容器，水平或垂直布局 Split 分割布局 Scroll 滚动布局 3 应用框架 toga.App 应用入口 toga.MainWindow 主窗口 控件通过 add 方法加入窗口 4 打包工具 Briefcase 用于打包应用 支持打包成桌面安装包、移动端 APK/IPA、Web 应用 13.6.3 原理 Toga 定义了一套跨平台 API 每个平台使用本地的原生控件来渲染界面 BeeWare 的 Briefcase 会把 Python 应用打包成原生可执行文件 最终用户使用时，界面和体验与本地应用一致 13.6.4 应用 跨平台桌面应用 移动应用（Android、iOS） Web 应用（实验性支持） 用 Python 开发并部署到多平台的工具 13.6.5 举例 最简单的应用 import toga def on_press(widget): print(&quot;按钮被点击&quot;) def build(app): button = toga.Button(&quot;点我&quot;, on_press=on_press) return toga.Box(children=[button]) def main(): return toga.App(&quot;我的应用&quot;, &quot;org.example.myapp&quot;, startup=build) if __name__ == &quot;__main__&quot;: main().main_loop() 带窗口和标签 import toga def build(app): box = toga.Box() label = toga.Label(&quot;你好，BeeWare Toga&quot;) box.add(label) return box def main(): return toga.App(&quot;Hello Toga&quot;, &quot;org.example.hellotoga&quot;, startup=build) if __name__ == &quot;__main__&quot;: main().main_loop() 13.6.6 辨析 1 误解 BeeWare 只是另一个 GUI 库 实际 BeeWare 是一整套跨平台开发和打包工具，Toga 是其中的 GUI 部分 2 误解 Toga 的界面是模拟的 实际 Toga 使用系统原生控件，外观和体验与本地应用一致 3 误解 BeeWare 已经很成熟 实际 BeeWare 还在积极开发中，生态和文档不如 PyQt 等成熟框架完善 13.6.7 总结 BeeWare/Toga 优点：写一次代码，多平台运行，界面原生，未来潜力大 缺点：生态还在发展中，控件种类和资料有限 适合：想用 Python 写跨平台应用，尤其是需要同时支持桌面和移动端的场景 "],["project.html", "Chapter 14 项目开发 14.1 一 想法到项目的鸿沟在哪里 14.2 二 如何跨越鸿沟 14.3 三 如何画设计图 14.4 四 行动计划 14.5 一 环境搭建类 14.6 二 功能开发类 14.7 三 文档写作类 14.8 四 测试类 14.9 五 发布与迭代类", " Chapter 14 项目开发 14.1 一 想法到项目的鸿沟在哪里 1 抽象 vs 具体 想法往往是模糊的、宏观的 项目需要具体的功能、时间、资源 2 无限可能 vs 约束条件 想法没有限制，什么都可以 项目必须考虑成本、技术、时间、风险 3 兴奋点 vs 细节执行 想法往往抓住亮点 项目必须落实到代码、数据表、接口、测试 14.2 二 如何跨越鸿沟 1 拆解 把想法拆成目标、子目标、模块、任务 例：一个“AI 学习助手” → 目标：回答问题 → 模块：用户界面、知识检索、答案生成 → 任务：UI 原型、数据库结构、模型调用 2 约束化 明确时间、资源、优先级 哪些必须做，哪些可以延后 3 原型化 先做出简单可运行的版本 不追求完美，先让想法“落地” 4 迭代化 原型验证 → 调整 → 增加功能 每一轮都把模糊的想法变得更具体 14.3 三 如何画设计图 这里的“设计图”不是艺术绘图，而是结构化思考的可视化。常见方法有： 1 思维导图 用来抓取和扩展想法 把核心想法放中间，往外分支功能、场景、用户需求 2 流程图 用来表示用户流程、系统逻辑 例：用户点击按钮 → 系统查询数据库 → 显示结果 3 架构图 用来展示模块关系 例：前端界面 → 后端 API → 数据库 → 外部服务 4 甘特图或看板 用来规划任务和时间 例：第 1 周完成原型，第 2 周做测试，第 3 周迭代 14.4 四 行动计划 1 先画一个思维导图，把想法展开 2 提炼出核心目标和关键功能 3 用流程图画用户交互过程 4 用架构图画技术模块关系 5 最后把任务排到时间表里 14.5 一 环境搭建类 14.5.1 1 创建 Python 虚拟环境 任务目标：为项目创建隔离的 Python 环境 前置条件：安装了 Python3 执行步骤： 打开终端，进入项目目录 创建环境：python -m venv venv 激活环境： macOS/Linux: source venv/bin/activate Windows: venv\\Scripts\\activate 安装依赖：pip install -r requirements.txt 检查标准：运行 pip list 显示预期依赖 注意事项：避免在全局环境安装，确保 requirements.txt 更新 14.5.2 2 Git 项目初始化 任务目标：用 Git 管理项目代码 前置条件：安装 git 执行步骤： 进入项目目录 初始化仓库：git init 创建 .gitignore 文件（忽略 venv、pycache 等） 添加文件：git add . 提交代码：git commit -m \"init project\" 检查标准：git log 能看到提交历史 注意事项：不要把敏感文件（密钥、配置）提交 14.6 二 功能开发类 14.6.1 3 搭建最小 API 服务（Flask） 任务目标：写一个可运行的 API，返回“Hello World” 前置条件：已安装 Flask 执行步骤： 新建 app.py 写入代码 from flask import Flask app = Flask(__name__) @app.route(&quot;/hello&quot;) def hello(): return &quot;Hello World&quot; if __name__ == &quot;__main__&quot;: app.run(debug=True) 运行：python app.py 打开浏览器访问 http://127.0.0.1:5000/hello 检查标准：页面返回“Hello World” 注意事项：端口冲突时修改 app.run(port=8000) 14.6.2 4 写一个命令行工具（argparse） 任务目标：用 argparse 写命令行脚本 前置条件：Python 环境 执行步骤： 新建 tool.py 写入： import argparse parser = argparse.ArgumentParser(description=&quot;示例工具&quot;) parser.add_argument(&quot;--name&quot;, type=str, required=True, help=&quot;用户姓名&quot;) args = parser.parse_args() print(f&quot;你好, {args.name}&quot;) 运行：python tool.py --name 张三 检查标准：输出 你好, 张三 注意事项：参数要写清楚默认值和帮助信息 14.7 三 文档写作类 14.7.1 5 写项目说明文档 README 任务目标：写标准 README.md 前置条件：项目基本成型 执行步骤： 包含项目名称和一句话简介 描述功能和使用场景 写安装步骤（代码示例） 给出运行方式 添加许可证信息 检查标准：新手开发者能 5 分钟跑起来项目 注意事项：文档示例要能复制运行 14.7.2 6 画架构图 任务目标：展示系统模块关系 前置条件：确定项目模块 执行步骤： 选择工具（draw.io、XMind、PowerPoint） 放置核心模块（后端服务） 添加输入端（用户界面）和输出端（数据库/外部服务） 用箭头标注数据流 添加模块标签 检查标准：外行人能看懂系统怎么运作 注意事项：避免过度复杂，模块不超过 7 个 14.8 四 测试类 14.8.1 7 写一个 pytest 单元测试 任务目标：验证函数输出是否正确 前置条件：安装 pytest 执行步骤： 新建 test_math.py 写入： def add(a, b): return a + b def test_add(): assert add(2, 3) == 5 运行：pytest -v 检查标准：测试显示 PASSED 注意事项：测试文件和函数命名要以 test_ 开头 14.8.2 8 API 接口测试 任务目标：验证 API 正常返回数据 前置条件：安装 requests 执行步骤： 写一个 pytest 文件 import requests def test_api(): url = &quot;http://127.0.0.1:5000/hello&quot; response = requests.get(url) assert response.status_code == 200 assert &quot;Hello&quot; in response.text 运行：pytest -v 检查标准：接口返回 200 且包含预期内容 注意事项：确保服务在运行 14.9 五 发布与迭代类 14.9.1 9 打包 Python 项目 任务目标：发布一个可安装的包 前置条件：项目结构标准化 执行步骤： 新建 pyproject.toml 写入元信息（名称、版本、依赖） 运行：poetry build 生成 tar.gz 和 whl 文件 检查标准：能用 pip install 安装 注意事项：包名要唯一 14.9.2 10 部署到服务器 任务目标：把项目运行在远程服务器 前置条件：服务器有 Python 环境 执行步骤： 通过 ssh 登录服务器 拉取代码 git clone ... 创建虚拟环境并安装依赖 启动应用（Flask/Django/FastAPI） 配置 Nginx 反向代理 检查标准：公网能访问应用 注意事项：检查防火墙端口是否开放 "]]
